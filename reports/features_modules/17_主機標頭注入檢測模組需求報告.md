# ğŸ“¡ ä¸»æ©Ÿæ¨™é ­æ³¨å…¥æª¢æ¸¬æ¨¡çµ„éœ€æ±‚å ±å‘Š (Host Header Injection)

## ğŸ“ æ¨¡çµ„éƒ¨ç½²ä½ç½®
```
services/integration/capability/host_header_injection/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ __main__.py
â”œâ”€â”€ host_header_injection_detector.py # ä¸»æª¢æ¸¬å¼•æ“
â”œâ”€â”€ host_header_injection_scanner.py  # æƒæå”èª¿å™¨
â”œâ”€â”€ host_header_injection_exploiter.py # æ¼æ´åˆ©ç”¨å™¨
â”œâ”€â”€ cache_poisoning_detector.py       # å¿«å–æŠ•æ¯’æª¢æ¸¬
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ detection_rules.json
â”‚   â”œâ”€â”€ payload_templates.json
â”‚   â””â”€â”€ scanner_config.json
â”œâ”€â”€ payloads/
â”‚   â”œâ”€â”€ cache_poisoning_payloads.json
â”‚   â”œâ”€â”€ password_reset_payloads.json
â”‚   â””â”€â”€ routing_based_ssrf_payloads.json
â””â”€â”€ tests/
    â”œâ”€â”€ test_host_header_detector.py
    â”œâ”€â”€ test_host_header_scanner.py
    â””â”€â”€ test_integration.py
```

## ğŸ”— ç›¸é—œæ¨¡çµ„é€£çµ
- [å‘½ä»¤æ³¨å…¥æª¢æ¸¬](./11_å‘½ä»¤æ³¨å…¥æª¢æ¸¬æ¨¡çµ„éœ€æ±‚å ±å‘Š.md) - å…±äº«HTTPåƒæ•¸æ³¨å…¥æª¢æ¸¬
- [ç›®éŒ„éæ­·æ”»æ“Šæª¢æ¸¬](./13_ç›®éŒ„éæ­·æ”»æ“Šæª¢æ¸¬æ¨¡çµ„éœ€æ±‚å ±å‘Š.md) - å…±äº«è·¯å¾‘æ“ä½œæŠ€è¡“
- [NoSQLæ³¨å…¥æª¢æ¸¬](./16_NoSQLæ³¨å…¥æª¢æ¸¬æ¨¡çµ„éœ€æ±‚å ±å‘Š.md) - å…±äº«HTTPåƒæ•¸æ³¨å…¥æª¢æ¸¬
- [ç¼ºå£åˆ†æå ±å‘Š](./10_AIVAæ¼æ´æª¢æ¸¬ç¼ºå£åˆ†æ.md) - ç¸½é«”æ¶æ§‹è¦åŠƒåƒè€ƒ
- [å®Œæ•´TODOæ’åºè¨ˆåŠƒ](./00_å®Œæ•´TODOæ’åºèˆ‡éœ€æ±‚æ–‡ä»¶è£œé½Šè¨ˆåŠƒ.md) - å¯¦æ–½å„ªå…ˆç´šåƒè€ƒ

**å ±å‘Šç·¨è™Ÿ**: FEAT-017  
**æ—¥æœŸ**: 2025å¹´11æœˆ7æ—¥  
**ç‹€æ…‹**: ğŸš¨ Critical Priority - ä½è¤‡é›œåº¦é«˜ROI  
**å„ªå…ˆç´š**: P0 (Critical Priority)  
**é æœŸæ”¶ç›Š**: $40K-70K/å¹´  
**OWASP ç·¨è™Ÿ**: WSTG-07-17

---

## ğŸ“Š å¸‚å ´éœ€æ±‚åˆ†æ

### ğŸ’° è³é‡‘åƒ¹å€¼è©•ä¼°
- **å…¸å‹è³é‡‘ç¯„åœ**: $200-$2,500 (ä¸­ç­‰åƒ¹å€¼)
- **ç™¼ç¾é »ç‡**: é«˜ (50-70%çš„æ‡‰ç”¨å­˜åœ¨Hostæ¨™é ­ä¿¡ä»»å•é¡Œ)
- **æª¢æ¸¬æˆåŠŸç‡**: 90-95% (æª¢æ¸¬ç›¸å°ç°¡å–®)
- **å¹´æ”¶ç›Šé æ¸¬**: $40K-70K

### ğŸ¯ ç›®æ¨™æŠ€è¡“æ£§åˆ†å¸ƒ
- **PHPæ‡‰ç”¨**: 40%å¸‚å ´ä½”æœ‰ç‡ (æœ€å¸¸è¦‹çš„ä¿¡ä»»Hostæ¨™é ­)
- **Javaæ‡‰ç”¨**: 25%å¸‚å ´ä½”æœ‰ç‡ (Spring Booté è¨­è¡Œç‚º)
- **Pythonæ‡‰ç”¨**: 20%å¸‚å ´ä½”æœ‰ç‡ (Django, Flaskå¸¸è¦‹)
- **.NETæ‡‰ç”¨**: 10%å¸‚å ´ä½”æœ‰ç‡ (ASP.NETé…ç½®å•é¡Œ)
- **å…¶ä»–å¹³å°**: 5%å¸‚å ´ä½”æœ‰ç‡ (Node.js, Ruby)

### ğŸš¨ é«˜é¢¨éšªå ´æ™¯
- å¯†ç¢¼é‡ç½®åŠŸèƒ½ - 95%é¢¨éšª (Hostæ¨™é ­ç”¨æ–¼ç”Ÿæˆé‡ç½®é€£çµ)
- é›»å­éƒµä»¶æ¨¡æ¿ - 90%é¢¨éšª (å‹•æ…‹ç”Ÿæˆé€£çµ)
- å¿«å–ç³»çµ± - 85%é¢¨éšª (Hostæ¨™é ­ä½œç‚ºå¿«å–éµ)
- è² è¼‰å‡è¡¡å™¨ - 80%é¢¨éšª (åå‘ä»£ç†é…ç½®)
- SSLé‡å®šå‘ - 75%é¢¨éšª (HTTPSè·³è½‰é‚è¼¯)

---

## ğŸ” æŠ€è¡“éœ€æ±‚è¦æ ¼

### **æ¨¡çµ„æ¨™è­˜**
```
æœå‹™è·¯å¾‘: services/integration/capability/host_header_injection/
æ¨¡çµ„åç¨±: Host Header Injection Detection Engine
è²¬ä»»åœ˜éšŠ: Core Security Research Team
å¯¦ç¾èªè¨€: Go (ä¸»å¼•æ“) + Python (æ¥­å‹™é‚è¼¯åˆ†æ)
è¤‡é›œåº¦ç´šåˆ¥: Low-Medium
```

### **æ ¸å¿ƒæª¢æ¸¬èƒ½åŠ›**

#### 1ï¸âƒ£ **åŸºç¤Hostæ¨™é ­æ³¨å…¥æª¢æ¸¬**
```go
package detector

import (
    "context"
    "fmt"
    "net/http"
    "strings"
    "time"
    
    "go.uber.org/zap"
    schemas "github.com/kyle0527/aiva/services/function/common/go/aiva_common_go/schemas/generated"
)

// HostHeaderInjectionDetector Hostæ¨™é ­æ³¨å…¥æª¢æ¸¬å™¨
type HostHeaderInjectionDetector struct {
    logger           *zap.Logger
    client          *http.Client
    payloads        []string
    collaborator    string
    testDomains     []string
}

// NewHostHeaderInjectionDetector å»ºç«‹æª¢æ¸¬å™¨
func NewHostHeaderInjectionDetector(logger *zap.Logger, collaborator string) *HostHeaderInjectionDetector {
    return &HostHeaderInjectionDetector{
        logger:      logger,
        client:      &http.Client{Timeout: 30 * time.Second},
        collaborator: collaborator,
        payloads:    loadHostHeaderPayloads(),
        testDomains: []string{
            "evil-attacker.com",
            "malicious-host.net", 
            "hhi-test.example.com",
            collaborator,
        },
    }
}

func loadHostHeaderPayloads() []string {
    return []string{
        // åŸºæœ¬Hostæ¨™é ­æ›¿æ›
        "evil-attacker.com",
        "malicious-host.net",
        "127.0.0.1",
        "localhost",
        
        // ç«¯å£è®Šé«”
        "evil-attacker.com:80",
        "evil-attacker.com:443", 
        "127.0.0.1:22",
        "localhost:3306",
        
        // Hostæ¨™é ­æ³¨å…¥æŠ€è¡“
        "original-host.com#evil-attacker.com",
        "original-host.com@evil-attacker.com",
        "original-host.com/evil-attacker.com",
        "original-host.com?evil-attacker.com",
        
        // å¤šHostæ¨™é ­
        "Host: legitimate.com\r\nHost: evil-attacker.com",
        
        // ç‰¹æ®Šå­—ç¬¦æ³¨å…¥
        "evil-attacker.com\\r\\nLocation: http://evil.com",
        "evil-attacker.com\\r\\nSet-Cookie: malicious=1",
        
        // IPåœ°å€è®Šé«”
        "192.168.1.1",
        "10.0.0.1", 
        "172.16.0.1",
        "0.0.0.0",
        
        // åœ‹éš›åŒ–åŸŸå (IDN)
        "Ñ…Ğ¾ÑÑ‚.Ğ·Ğ»Ğ¾Ğ½Ğ°Ğ¼ĞµÑ€ĞµĞ½Ğ½Ñ‹Ğ¹.Ñ€Ñ„", // Cyrillic characters
        "××–×™×§.×“×•×’××”.×™×©×¨××œ",        // Hebrew characters
    }
}

// DetectHostHeaderInjection æª¢æ¸¬Hostæ¨™é ­æ³¨å…¥æ¼æ´
func (h *HostHeaderInjectionDetector) DetectHostHeaderInjection(
    ctx context.Context, 
    task schemas.ScanTaskPayload,
) ([]schemas.FindingPayload, error) {
    
    baseURL := task.Target.URL.(string)
    findings := []schemas.FindingPayload{}
    
    h.logger.Info("Starting Host Header Injection detection",
        zap.String("target", baseURL),
        zap.Int("payloads", len(h.payloads)),
    )
    
    // ç²å¾—åŸºæº–éŸ¿æ‡‰
    baseline, err := h.sendRequest(ctx, baseURL, "")
    if err != nil {
        return nil, fmt.Errorf("failed to get baseline response: %w", err)
    }
    
    // æ¸¬è©¦å„ç¨®Hostæ¨™é ­è¼‰è·
    for _, payload := range h.payloads {
        finding := h.testHostHeaderPayload(ctx, baseURL, payload, baseline, task.TaskID)
        if finding != nil {
            findings = append(findings, *finding)
        }
        
        // é¿å…éæ–¼é »ç¹çš„è«‹æ±‚
        time.Sleep(200 * time.Millisecond)
    }
    
    // ç‰¹æ®Šæª¢æ¸¬ï¼šå¯†ç¢¼é‡ç½®åŠŸèƒ½
    passwordResetFindings := h.detectPasswordResetVulnerability(ctx, baseURL, task.TaskID)
    findings = append(findings, passwordResetFindings...)
    
    // ç‰¹æ®Šæª¢æ¸¬ï¼šå¿«å–æ±¡æŸ“
    cachePoisoningFindings := h.detectCachePoisoning(ctx, baseURL, task.TaskID)
    findings = append(findings, cachePoisoningFindings...)
    
    return findings, nil
}

func (h *HostHeaderInjectionDetector) testHostHeaderPayload(
    ctx context.Context,
    baseURL string,
    payload string,
    baseline *http.Response,
    taskID string,
) *schemas.FindingPayload {
    
    // ç™¼é€å¸¶æœ‰æƒ¡æ„Hostæ¨™é ­çš„è«‹æ±‚
    response, err := h.sendRequest(ctx, baseURL, payload)
    if err != nil {
        h.logger.Debug("Request failed", zap.String("payload", payload), zap.Error(err))
        return nil
    }
    defer response.Body.Close()
    
    // åˆ†æéŸ¿æ‡‰å·®ç•°
    vulnerability := h.analyzeHostHeaderResponse(response, baseline, payload)
    if vulnerability == nil {
        return nil
    }
    
    return h.createFinding(taskID, baseURL, payload, vulnerability, response)
}

func (h *HostHeaderInjectionDetector) analyzeHostHeaderResponse(
    response *http.Response,
    baseline *http.Response,
    payload string,
) *HostHeaderVulnerability {
    
    responseBody := readResponseBody(response)
    baselineBody := readResponseBody(baseline)
    
    // æª¢æŸ¥1: éŸ¿æ‡‰ä¸­æ˜¯å¦åå°„äº†æƒ¡æ„Host
    if strings.Contains(responseBody, payload) {
        return &HostHeaderVulnerability{
            Type:        "Host Header Reflection",
            Description: "Malicious host header reflected in response body",
            Severity:    "High",
            Evidence:    fmt.Sprintf("Payload '%s' found in response", payload),
        }
    }
    
    // æª¢æŸ¥2: Locationæ¨™é ­ä¸­çš„é‡å®šå‘
    location := response.Header.Get("Location")
    if location != "" && strings.Contains(location, payload) {
        return &HostHeaderVulnerability{
            Type:        "Host Header Redirect",
            Description: "Malicious host header used in redirect location",
            Severity:    "Critical",
            Evidence:    fmt.Sprintf("Location header: %s", location),
        }
    }
    
    // æª¢æŸ¥3: Set-Cookieæ¨™é ­ä¸­çš„åŸŸ
    setCookie := response.Header.Get("Set-Cookie")
    if setCookie != "" && strings.Contains(setCookie, payload) {
        return &HostHeaderVulnerability{
            Type:        "Host Header Cookie Injection",
            Description: "Malicious host header affects cookie domain",
            Severity:    "High",
            Evidence:    fmt.Sprintf("Set-Cookie header: %s", setCookie),
        }
    }
    
    // æª¢æŸ¥4: å…¶ä»–æ¨™é ­ä¸­çš„åå°„
    suspiciousHeaders := []string{
        "Link", "Content-Location", "X-Forwarded-Host", "X-Host", "Origin",
    }
    
    for _, headerName := range suspiciousHeaders {
        headerValue := response.Header.Get(headerName)
        if headerValue != "" && strings.Contains(headerValue, payload) {
            return &HostHeaderVulnerability{
                Type:        "Host Header Injection in Headers",
                Description: fmt.Sprintf("Malicious host header reflected in %s header", headerName),
                Severity:    "Medium",
                Evidence:    fmt.Sprintf("%s header: %s", headerName, headerValue),
            }
        }
    }
    
    // æª¢æŸ¥5: ç‹€æ…‹ç¢¼ç•°å¸¸
    if response.StatusCode != baseline.StatusCode {
        // ç‰¹åˆ¥é—œæ³¨é‡å®šå‘ç‹€æ…‹ç¢¼
        if response.StatusCode >= 300 && response.StatusCode < 400 {
            return &HostHeaderVulnerability{
                Type:        "Host Header Status Change",
                Description: "Host header manipulation causes redirect",
                Severity:    "Medium",
                Evidence:    fmt.Sprintf("Status changed from %d to %d", baseline.StatusCode, response.StatusCode),
            }
        }
    }
    
    // æª¢æŸ¥6: éŸ¿æ‡‰é«”é•·åº¦é¡¯è‘—å·®ç•°
    sizeDiff := len(responseBody) - len(baselineBody)
    if abs(sizeDiff) > 100 { // 100å­—ç¯€ä»¥ä¸Šå·®ç•°
        if strings.Contains(responseBody, "error") || strings.Contains(responseBody, "exception") {
            return &HostHeaderVulnerability{
                Type:        "Host Header Error Disclosure",
                Description: "Host header manipulation triggers error disclosure",
                Severity:    "Low",
                Evidence:    fmt.Sprintf("Response size difference: %d bytes", sizeDiff),
            }
        }
    }
    
    return nil
}

// HostHeaderVulnerability Hostæ¨™é ­æ¼æ´çµæ§‹
type HostHeaderVulnerability struct {
    Type        string
    Description string
    Severity    string
    Evidence    string
}
```

#### 2ï¸âƒ£ **å¯†ç¢¼é‡ç½®åŠŸèƒ½æª¢æ¸¬**
```go
func (h *HostHeaderInjectionDetector) detectPasswordResetVulnerability(
    ctx context.Context,
    baseURL string,
    taskID string,
) []schemas.FindingPayload {
    
    findings := []schemas.FindingPayload{}
    
    // å¸¸è¦‹çš„å¯†ç¢¼é‡ç½®ç«¯é»
    resetEndpoints := []string{
        "/password/reset",
        "/forgot-password",
        "/reset-password", 
        "/password/forgot",
        "/auth/password/reset",
        "/account/password/reset",
        "/user/password/reset",
        "/password-reset",
        "/forgot",
        "/reset",
    }
    
    for _, endpoint := range resetEndpoints {
        fullURL := baseURL + endpoint
        
        // æª¢æŸ¥ç«¯é»æ˜¯å¦å­˜åœ¨
        if !h.endpointExists(ctx, fullURL) {
            continue
        }
        
        h.logger.Info("Testing password reset endpoint", zap.String("endpoint", fullURL))
        
        // æ¸¬è©¦å¯†ç¢¼é‡ç½®åŠŸèƒ½
        finding := h.testPasswordResetHostInjection(ctx, fullURL, taskID)
        if finding != nil {
            findings = append(findings, *finding)
        }
    }
    
    return findings
}

func (h *HostHeaderInjectionDetector) testPasswordResetHostInjection(
    ctx context.Context,
    resetURL string,
    taskID string,
) *schemas.FindingPayload {
    
    maliciousHost := h.collaborator
    testEmail := "test@example.com"
    
    // æ§‹é€ å¯†ç¢¼é‡ç½®è«‹æ±‚
    data := fmt.Sprintf("email=%s", testEmail)
    
    req, err := http.NewRequestWithContext(ctx, "POST", resetURL, strings.NewReader(data))
    if err != nil {
        return nil
    }
    
    // è¨­ç½®æƒ¡æ„Hostæ¨™é ­
    req.Header.Set("Host", maliciousHost)
    req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
    req.Header.Set("User-Agent", "AIVA-Security-Scanner/1.0")
    
    response, err := h.client.Do(req)
    if err != nil {
        return nil
    }
    defer response.Body.Close()
    
    responseBody := readResponseBody(response)
    
    // æª¢æŸ¥éŸ¿æ‡‰ä¸­æ˜¯å¦åŒ…å«æƒ¡æ„åŸŸå
    if strings.Contains(responseBody, maliciousHost) {
        return h.createPasswordResetFinding(taskID, resetURL, maliciousHost, responseBody)
    }
    
    // æª¢æŸ¥å”ä½œæœå‹™å™¨æ˜¯å¦æ”¶åˆ°è«‹æ±‚ (é›»å­éƒµä»¶ä¸­çš„é€£çµ)
    time.Sleep(5 * time.Second) // ç­‰å¾…é›»å­éƒµä»¶è™•ç†
    
    if h.checkCollaboratorInteraction(maliciousHost) {
        return h.createPasswordResetFinding(taskID, resetURL, maliciousHost, "Email sent with malicious host")
    }
    
    return nil
}
```

#### 3ï¸âƒ£ **å¿«å–æ±¡æŸ“æª¢æ¸¬**
```go
func (h *HostHeaderInjectionDetector) detectCachePoisoning(
    ctx context.Context,
    baseURL string,
    taskID string,
) []schemas.FindingPayload {
    
    findings := []schemas.FindingPayload{}
    
    // æ¸¬è©¦å¿«å–æ±¡æŸ“æ”»æ“Š
    cacheTestPayload := fmt.Sprintf("cache-poison-%d.%s", time.Now().Unix(), h.collaborator)
    
    // ç¬¬ä¸€æ­¥ï¼šå˜—è©¦æ±¡æŸ“å¿«å–
    req1, _ := http.NewRequestWithContext(ctx, "GET", baseURL, nil)
    req1.Header.Set("Host", cacheTestPayload)
    req1.Header.Set("X-Forwarded-Host", cacheTestPayload)
    req1.Header.Set("X-Host", cacheTestPayload)
    req1.Header.Set("X-Original-URL", "/")
    
    response1, err := h.client.Do(req1)
    if err != nil {
        return findings
    }
    response1.Body.Close()
    
    // ç­‰å¾…å¿«å–ç”Ÿæ•ˆ
    time.Sleep(2 * time.Second)
    
    // ç¬¬äºŒæ­¥ï¼šç™¼é€æ­£å¸¸è«‹æ±‚æª¢æŸ¥æ˜¯å¦è¢«æ±¡æŸ“
    req2, _ := http.NewRequestWithContext(ctx, "GET", baseURL, nil)
    // ä¸è¨­ç½®ç‰¹æ®Šæ¨™é ­ï¼Œä½¿ç”¨æ­£å¸¸Host
    
    response2, err := h.client.Do(req2)
    if err != nil {
        return findings
    }
    defer response2.Body.Close()
    
    responseBody2 := readResponseBody(response2)
    
    // æª¢æŸ¥æ­£å¸¸è«‹æ±‚æ˜¯å¦è¿”å›äº†æ±¡æŸ“çš„å…§å®¹
    if strings.Contains(responseBody2, cacheTestPayload) {
        finding := h.createCachePoisoningFinding(taskID, baseURL, cacheTestPayload, responseBody2)
        findings = append(findings, *finding)
    }
    
    return findings
}
```

---

## ğŸ—ï¸ æ¶æ§‹è¨­è¨ˆ

### **æ¨¡çµ„çµæ§‹**
```
services/integration/capability/host_header_injection/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ main.go                         # Goæœå‹™å…¥å£
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ detector/
â”‚   â”‚   â”œâ”€â”€ host_header_detector.go     # ä¸»æª¢æ¸¬å¼•æ“
â”‚   â”‚   â”œâ”€â”€ password_reset_tester.go    # å¯†ç¢¼é‡ç½®æ¸¬è©¦å™¨
â”‚   â”‚   â”œâ”€â”€ cache_poisoning_tester.go   # å¿«å–æ±¡æŸ“æ¸¬è©¦å™¨
â”‚   â”‚   â”œâ”€â”€ payload_generator.go        # è¼‰è·ç”Ÿæˆå™¨
â”‚   â”‚   â””â”€â”€ response_analyzer.go        # éŸ¿æ‡‰åˆ†æå™¨
â”‚   â”œâ”€â”€ engine/
â”‚   â”‚   â”œâ”€â”€ scanner.go                  # ä¸»æƒæå¼•æ“
â”‚   â”‚   â”œâ”€â”€ collaborator.go             # å”ä½œæœå‹™å™¨å®¢æˆ¶ç«¯
â”‚   â”‚   â””â”€â”€ reporter.go                 # å ±å‘Šç”Ÿæˆå™¨
â”‚   â”œâ”€â”€ business_logic/
â”‚   â”‚   â”œâ”€â”€ email_template_analyzer.py  # é›»å­éƒµä»¶æ¨¡æ¿åˆ†æ (Python)
â”‚   â”‚   â”œâ”€â”€ reset_flow_tracer.py        # é‡ç½®æµç¨‹è¿½è¹¤
â”‚   â”‚   â””â”€â”€ cache_behavior_analyzer.py  # å¿«å–è¡Œç‚ºåˆ†æ
â”‚   â””â”€â”€ worker/
â”‚       â”œâ”€â”€ amqp_consumer.go            # æ¶ˆæ¯æ¶ˆè²»è€…
â”‚       â””â”€â”€ task_processor.go           # ä»»å‹™è™•ç†å™¨
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ payloads/
â”‚   â”‚   â”œâ”€â”€ basic_hosts.yaml            # åŸºæœ¬Hostè¼‰è·
â”‚   â”‚   â”œâ”€â”€ injection_techniques.yaml   # æ³¨å…¥æŠ€è¡“è¼‰è·
â”‚   â”‚   â”œâ”€â”€ international_domains.yaml  # åœ‹éš›åŒ–åŸŸå
â”‚   â”‚   â””â”€â”€ port_variations.yaml        # ç«¯å£è®Šé«”
â”‚   â”œâ”€â”€ endpoints/
â”‚   â”‚   â”œâ”€â”€ password_reset_paths.yaml   # å¯†ç¢¼é‡ç½®è·¯å¾‘
â”‚   â”‚   â”œâ”€â”€ common_endpoints.yaml       # å¸¸è¦‹ç«¯é»
â”‚   â”‚   â””â”€â”€ cache_targets.yaml          # å¿«å–ç›®æ¨™
â”‚   â”œâ”€â”€ signatures/
â”‚   â”‚   â”œâ”€â”€ reflection_patterns.yaml    # åå°„æ¨¡å¼
â”‚   â”‚   â”œâ”€â”€ redirect_patterns.yaml      # é‡å®šå‘æ¨¡å¼  
â”‚   â”‚   â””â”€â”€ error_patterns.yaml         # éŒ¯èª¤æ¨¡å¼
â”‚   â””â”€â”€ rules.yaml                      # æª¢æ¸¬è¦å‰‡
â””â”€â”€ tests/
    â”œâ”€â”€ unit/
    â”œâ”€â”€ integration/
    â””â”€â”€ vulnerable_apps/                # æ¸¬è©¦æ‡‰ç”¨
```

### **æª¢æ¸¬å·¥ä½œæµ**
```mermaid
graph TD
    A[ç›®æ¨™URL] --> B[åŸºæº–è«‹æ±‚]
    B --> C[Hostæ¨™é ­è¼‰è·æ¸¬è©¦]
    C --> D[åŸºæœ¬Hostæ›¿æ›]
    D --> E[æ³¨å…¥æŠ€è¡“æ¸¬è©¦]
    E --> F[å¤šHostæ¨™é ­æ¸¬è©¦]
    F --> G[éŸ¿æ‡‰åˆ†æ]
    G --> H{æª¢æ¸¬åˆ°ç•°å¸¸?}
    H -->|Yes| I[æ¼æ´åˆ†é¡]
    H -->|No| J[å¯†ç¢¼é‡ç½®æª¢æ¸¬]
    J --> K[é‡ç½®ç«¯é»ç™¼ç¾]
    K --> L[Hostæ³¨å…¥æ¸¬è©¦]
    L --> M[é›»å­éƒµä»¶è¿½è¹¤]
    M --> N{é‡ç½®åŠŸèƒ½æ¼æ´?}
    N -->|Yes| O[å¿«å–æ±¡æŸ“æª¢æ¸¬]
    N -->|No| O
    O --> P[å¿«å–æ±¡æŸ“æ¸¬è©¦]
    P --> Q[æ­£å¸¸è«‹æ±‚é©—è­‰]
    Q --> R{å¿«å–è¢«æ±¡æŸ“?}
    R -->|Yes| S[çµæœå½™ç¸½]
    R -->|No| S
    I --> S
    S --> T[SARIFå ±å‘Š]
```

---

## âš™ï¸ é…ç½®æ–‡ä»¶è¦æ ¼

### **ä¸»é…ç½®æ–‡ä»¶**
```yaml
# config/rules.yaml
host_header_injection_detection:
  enabled: true
  timeout: 30
  max_payloads_per_target: 30
  
  basic_detection:
    enabled: true
    reflection_check: true
    redirect_check: true
    header_injection: true
    status_change_check: true
    
  password_reset_detection:
    enabled: true
    common_endpoints: true
    email_tracking: true
    collaboration_timeout: 30
    
  cache_poisoning_detection:
    enabled: true
    poison_wait_time: 2
    verification_requests: 3
    
  collaborator:
    server: "hhi.aiva-security.com"
    timeout: 30
    interaction_check_interval: 5
    
  confidence_thresholds:
    critical: 0.95  # é‡å®šå‘ã€å¯†ç¢¼é‡ç½®
    high: 0.85      # éŸ¿æ‡‰åå°„
    medium: 0.7     # æ¨™é ­æ³¨å…¥
    low: 0.5        # ç‹€æ…‹è®ŠåŒ–
    
  rate_limiting:
    requests_per_second: 10
    burst_limit: 20
    delay_between_requests: 200ms
```

### **Hostè¼‰è·é…ç½®**
```yaml  
# config/payloads/basic_hosts.yaml
host_payloads:
  basic_domains:
    - payload: "evil-attacker.com"
      description: "Basic malicious domain"
      severity: "medium"
      
    - payload: "hhi-test.example.com"
      description: "Test domain for HHI"
      severity: "medium"
      
    - payload: "127.0.0.1"
      description: "Localhost IP"
      severity: "high"
      
    - payload: "169.254.169.254"
      description: "AWS metadata service"
      severity: "critical"
      
  port_variations:
    - payload: "evil-attacker.com:80"
      description: "HTTP port variation"
      
    - payload: "evil-attacker.com:443"
      description: "HTTPS port variation"
      
    - payload: "127.0.0.1:22"
      description: "SSH port targeting"
      
    - payload: "127.0.0.1:3306"
      description: "MySQL port targeting"
      
  injection_techniques:
    - payload: "legitimate.com#evil-attacker.com"
      description: "Fragment injection"
      severity: "high"
      
    - payload: "legitimate.com@evil-attacker.com"
      description: "At-sign injection"
      severity: "high"
      
    - payload: "legitimate.com/evil-attacker.com"
      description: "Path injection"
      severity: "medium"
      
    - payload: "legitimate.com?evil-attacker.com"
      description: "Query injection"
      severity: "medium"
```

### **ç«¯é»é…ç½®**
```yaml
# config/endpoints/password_reset_paths.yaml
password_reset_endpoints:
  common_paths:
    - "/password/reset"
    - "/forgot-password"
    - "/reset-password"
    - "/password/forgot"
    - "/auth/password/reset"
    - "/account/password/reset"
    - "/user/password/reset"
    - "/password-reset"
    - "/forgot"
    - "/reset"
    
  framework_specific:
    wordpress:
      - "/wp-login.php?action=lostpassword"
      - "/wp-admin/profile.php"
      
    drupal:
      - "/user/password"
      - "/admin/people/permissions"
      
    laravel:
      - "/password/email"
      - "/password/reset"
      
    django:
      - "/accounts/password/reset/"
      - "/admin/password_change/"
      
  http_methods:
    - "POST"
    - "GET"
    - "PUT"
    - "PATCH"
```

---

## ğŸ§ª æ¸¬è©¦ç­–ç•¥

### **æ¼æ´æ‡‰ç”¨æ­å»º**
```php
<?php
// tests/vulnerable_apps/host_header_injection_test.php

// åŸºæœ¬Hostæ¨™é ­åå°„æ¼æ´
if (isset($_SERVER['HTTP_HOST'])) {
    $host = $_SERVER['HTTP_HOST'];
    echo "<h1>Welcome to " . $host . "</h1>";
    echo "<a href='http://" . $host . "/admin'>Admin Panel</a>";
}

// å¯†ç¢¼é‡ç½®åŠŸèƒ½æ¼æ´
if ($_POST['action'] == 'reset_password') {
    $email = $_POST['email'];
    $host = $_SERVER['HTTP_HOST'];
    
    // å±éšªï¼šç›´æ¥ä½¿ç”¨Hostæ¨™é ­ç”Ÿæˆé‡ç½®é€£çµ
    $reset_link = "http://" . $host . "/reset?token=" . md5($email . time());
    
    // æ¨¡æ“¬ç™¼é€é›»å­éƒµä»¶
    file_put_contents('emails.log', 
        "Reset link sent to $email: $reset_link\n", 
        FILE_APPEND
    );
    
    echo "Reset email sent!";
}

// é‡å®šå‘åŠŸèƒ½æ¼æ´
if ($_GET['redirect']) {
    $host = $_SERVER['HTTP_HOST'];
    $redirect_url = "http://" . $host . $_GET['redirect'];
    header("Location: " . $redirect_url);
    exit();
}

// å¿«å–éµç”Ÿæˆæ¼æ´
$cache_key = "page_" . $_SERVER['HTTP_HOST'] . "_" . $_SERVER['REQUEST_URI'];
echo "<!-- Cache key: " . $cache_key . " -->";
?>
```

```python
# Python Flaskæ¼æ´ç¤ºä¾‹
from flask import Flask, request, redirect, url_for

app = Flask(__name__)

@app.route('/')
def index():
    # å±éšªï¼šç›´æ¥ä½¿ç”¨Hostæ¨™é ­
    host = request.headers.get('Host', 'localhost')
    return f'<h1>Welcome to {host}</h1><a href="http://{host}/admin">Admin</a>'

@app.route('/reset', methods=['POST'])
def password_reset():
    email = request.form.get('email')
    host = request.headers.get('Host', 'localhost')
    
    # å±éšªï¼šé‡ç½®é€£çµåŒ…å«Hostæ¨™é ­
    reset_link = f"http://{host}/password/reset?token=abc123"
    
    # æ¨¡æ“¬ç™¼é€é›»å­éƒµä»¶
    with open('emails.log', 'a') as f:
        f.write(f"Reset link: {reset_link}\n")
    
    return "Reset email sent!"

@app.route('/redirect')
def redirect_page():
    host = request.headers.get('Host', 'localhost')
    path = request.args.get('path', '/')
    return redirect(f"http://{host}{path}")
```

### **è‡ªå‹•åŒ–æ¸¬è©¦**
```go
func TestHostHeaderInjectionDetection(t *testing.T) {
    detector := NewHostHeaderInjectionDetector(zap.NewNop(), "test.collaborator.com")
    
    // æ¸¬è©¦åŸºæœ¬Hostæ¨™é ­æ³¨å…¥
    task := schemas.ScanTaskPayload{
        TaskID: "test-001",
        Target: schemas.ScanTarget{
            URL: "http://localhost:8080/vulnerable",
        },
    }
    
    findings, err := detector.DetectHostHeaderInjection(context.Background(), task)
    assert.NoError(t, err)
    assert.Greater(t, len(findings), 0)
    
    // é©—è­‰æª¢æ¸¬åˆ°çš„æ¼æ´é¡å‹
    foundReflection := false
    foundRedirect := false
    
    for _, finding := range findings {
        if strings.Contains(finding.Title, "Host Header Reflection") {
            foundReflection = true
        }
        if strings.Contains(finding.Title, "Host Header Redirect") {  
            foundRedirect = true
        }
    }
    
    assert.True(t, foundReflection, "Should detect host header reflection")
    assert.True(t, foundRedirect, "Should detect redirect manipulation")
}

func TestPasswordResetDetection(t *testing.T) {
    detector := NewHostHeaderInjectionDetector(zap.NewNop(), "evil.collaborator.com")
    
    findings := detector.detectPasswordResetVulnerability(
        context.Background(),
        "http://localhost:8080",
        "test-002",
    )
    
    assert.Greater(t, len(findings), 0)
    
    // é©—è­‰å¯†ç¢¼é‡ç½®æ¼æ´æª¢æ¸¬
    found := false
    for _, finding := range findings {
        if strings.Contains(finding.Description, "password reset") {
            found = true
            assert.Equal(t, "Critical", finding.Severity)
            break
        }
    }
    
    assert.True(t, found, "Should detect password reset vulnerability")
}

func TestCachePoisoningDetection(t *testing.T) {
    detector := NewHostHeaderInjectionDetector(zap.NewNop(), "cache-poison.test.com")
    
    findings := detector.detectCachePoisoning(
        context.Background(),
        "http://localhost:8080/cached-page",
        "test-003",
    )
    
    // å¿«å–æ±¡æŸ“å¯èƒ½ä¸ç¸½æ˜¯æˆåŠŸï¼Œæ‰€ä»¥ä¸å¼·åˆ¶è¦æ±‚æª¢æ¸¬åˆ°
    if len(findings) > 0 {
        for _, finding := range findings {
            assert.Contains(t, finding.Title, "Cache Poisoning")
            assert.Equal(t, "Critical", finding.Severity)
        }
    }
}
```

---

## ğŸ“ˆ æ€§èƒ½è¦æ±‚

### **æƒææ€§èƒ½**
- **å–®ç›®æ¨™æƒææ™‚é–“**: < 45ç§’ (åŒ…å«æ‰€æœ‰æª¢æ¸¬)
- **ä¸¦ç™¼è«‹æ±‚æ•¸**: 10å€‹ä¸¦ç™¼é€£æ¥  
- **è¼‰è·æ¸¬è©¦æ•¸é‡**: 30å€‹æ¨™æº–è¼‰è·
- **å…§å­˜ä½¿ç”¨**: < 128MB/å¯¦ä¾‹

### **æª¢æ¸¬æº–ç¢ºç‡**
- **åŸºæœ¬Hostæ³¨å…¥æˆåŠŸç‡**: > 90%
- **å¯†ç¢¼é‡ç½®æª¢æ¸¬æˆåŠŸç‡**: > 85%  
- **å¿«å–æ±¡æŸ“æª¢æ¸¬æˆåŠŸç‡**: > 70%
- **ç¸½é«”èª¤å ±ç‡**: < 5%

---

## ğŸš€ å¯¦æ–½è¨ˆåŠƒ

### **Phase 1: åŸºç¤æª¢æ¸¬å¼•æ“ (1é€±)**
- [ ] Goä¸»æª¢æ¸¬å¼•æ“å¯¦ç¾
- [ ] åŸºæœ¬Hostæ¨™é ­è¼‰è·åº«
- [ ] HTTPå®¢æˆ¶ç«¯å’ŒéŸ¿æ‡‰åˆ†æ
- [ ] åŸºæœ¬æ¼æ´é¡å‹æª¢æ¸¬

### **Phase 2: å¯†ç¢¼é‡ç½®æª¢æ¸¬ (1é€±)**  
- [ ] å¯†ç¢¼é‡ç½®ç«¯é»ç™¼ç¾
- [ ] é‡ç½®åŠŸèƒ½æ¸¬è©¦å™¨
- [ ] é›»å­éƒµä»¶è¿½è¹¤æ©Ÿåˆ¶
- [ ] å”ä½œæœå‹™å™¨æ•´åˆ

### **Phase 3: é«˜ç´šæª¢æ¸¬æŠ€è¡“ (3å¤©)**
- [ ] å¿«å–æ±¡æŸ“æª¢æ¸¬
- [ ] å¤šHostæ¨™é ­è™•ç†
- [ ] åœ‹éš›åŒ–åŸŸåæ”¯æŒ
- [ ] æ³¨å…¥æŠ€è¡“è®Šé«”

### **Phase 4: é›†æˆå’Œå„ªåŒ– (3å¤©)**
- [ ] çµæœæ•´åˆå»é‡
- [ ] æ€§èƒ½èª¿å„ª
- [ ] SARIFå ±å‘Šç”Ÿæˆ  
- [ ] å…¨é¢æ¸¬è©¦

**ç¸½é–‹ç™¼å‘¨æœŸ**: 2é€±  
**é è¨ˆä¸Šç·šæ™‚é–“**: 2025å¹´11æœˆ21æ—¥

---

## ğŸ’¼ å•†æ¥­åƒ¹å€¼

### **æ”¶ç›Šåˆ†æ**
- **å¹´åº¦è³é‡‘æ”¶å…¥**: $40K-70K
- **é–‹ç™¼æŠ•è³‡**: $20K (2é€±é–‹ç™¼)  
- **ROI**: 100%-250%
- **å›æ”¶å‘¨æœŸ**: 3-6å€‹æœˆ

### **æŠ€è¡“åƒ¹å€¼**
- **æª¢æ¸¬è¦†è“‹ç‡**: æå‡è‡³36% (+4%)
- **å¿«é€ŸROI**: æœ€çŸ­å›æ”¶å‘¨æœŸé …ç›®
- **æŠ€è¡“åŸºç¤**: ç‚ºå…¶ä»–HTTPæ¨™é ­æ”»æ“Šå¥ å®šåŸºç¤

---

## ğŸ“‹ é©—æ”¶æ¨™æº–

### **åŠŸèƒ½é©—æ”¶**
- âœ… æ”¯æŒ30+ç¨®Hostæ¨™é ­è¼‰è·
- âœ… å¯†ç¢¼é‡ç½®åŠŸèƒ½å®Œæ•´æª¢æ¸¬
- âœ… å¿«å–æ±¡æŸ“æ”»æ“Šæª¢æ¸¬
- âœ… å¤šæ¡†æ¶ç«¯é»è‡ªå‹•ç™¼ç¾
- âœ… å”ä½œæœå‹™å™¨äº¤äº’è¿½è¹¤

### **æ€§èƒ½é©—æ”¶**
- âœ… æƒææ™‚é–“<45ç§’/ç›®æ¨™
- âœ… åŸºæœ¬æª¢æ¸¬æˆåŠŸç‡>90%
- âœ… å¯†ç¢¼é‡ç½®æˆåŠŸç‡>85%
- âœ… èª¤å ±ç‡<5%

---

## ğŸ¯ çµè«–

ä¸»æ©Ÿæ¨™é ­æ³¨å…¥æª¢æ¸¬æ¨¡çµ„æ˜¯ä¸€å€‹**ä½è¤‡é›œåº¦ã€é«˜ROI**çš„ç†æƒ³èµ·å§‹é …ç›®ã€‚å…¶æª¢æ¸¬é‚è¼¯ç›¸å°ç°¡å–®ï¼Œä½†åœ¨å¯¦æˆ°ä¸­ç™¼ç¾é »ç‡é«˜ï¼Œç‰¹åˆ¥æ˜¯å¯†ç¢¼é‡ç½®åŠŸèƒ½çš„æª¢æ¸¬å°‡å¸¶ä¾†ç©©å®šçš„ä¸­ç­‰åƒ¹å€¼è³é‡‘æ”¶å…¥ã€‚

**å»ºè­°ç«‹å³é–‹å§‹å¯¦æ–½**ï¼Œä½œç‚ºPhase 1çš„ç¬¬ä¸€å€‹é …ç›®ï¼Œç‚ºå¾ŒçºŒæ›´è¤‡é›œçš„æª¢æ¸¬æ¨¡çµ„å»ºç«‹æŠ€è¡“åŸºç¤å’Œé–‹ç™¼ä¿¡å¿ƒã€‚