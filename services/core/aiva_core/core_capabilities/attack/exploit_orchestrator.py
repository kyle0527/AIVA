"""Exploit Orchestrator - 漏洞利用編排器

✅ **符合五大模組架構** ✅
Core 模組負責**決策和編排**，不執行實際測試。

職責：
1. 管理 Exploit 註冊表和元數據
2. 選擇合適的 Exploit 策略
3. 編排 Features 模組執行測試
4. 從 Integration 收集和分析結果
5. 做出下一步決策

架構流程：
Core (決策) → MQ → Features (執行) → MQ → Integration (收集) → MQ → Core (分析)
"""

import logging
from typing import Any, Optional
from enum import Enum

try:
    from ....aiva_common.enums.security import ExploitType
except (ImportError, ValueError):
    from aiva_common.enums.security import ExploitType

logger = logging.getLogger(__name__)


class ExploitOrchestrator:
    """漏洞利用編排器
    
    負責編排漏洞測試流程，不執行實際測試：
    - Exploit 策略選擇
    - 參數配置和優化
    - 執行計劃制定
    - 結果分析和決策
    """

    def __init__(self):
        """初始化漏洞利用編排器"""
        self.exploit_registry: dict[str, dict[str, Any]] = {}
        self.execution_history: dict[str, list[dict[str, Any]]] = {}
        self._initialize_exploits()

        logger.info("ExploitOrchestrator initialized (orchestration mode)")

    def _initialize_exploits(self):
        """初始化內建漏洞利用元數據"""
        # SQL Injection
        self._register_exploit(
            {
                "id": "sqli_basic",
                "name": "Basic SQL Injection",
                "type": ExploitType.SQL_INJECTION,
                "severity": "high",
                "feature_module": "function_sqli",
                "payloads": [
                    "' OR '1'='1",
                    "' OR 1=1--",
                    "admin'--",
                    "' UNION SELECT NULL--",
                ],
                "targets": ["form", "url_param", "header"],
            }
        )

        # XSS
        self._register_exploit(
            {
                "id": "xss_reflected",
                "name": "Reflected XSS",
                "type": ExploitType.XSS,
                "severity": "medium",
                "feature_module": "function_xss",
                "payloads": [
                    "<script>alert('XSS')</script>",
                    "<img src=x onerror=alert('XSS')>",
                    "<svg onload=alert('XSS')>",
                ],
                "targets": ["form", "url_param"],
            }
        )

        # Command Injection
        self._register_exploit(
            {
                "id": "cmdi_basic",
                "name": "Command Injection",
                "type": ExploitType.COMMAND_INJECTION,
                "severity": "critical",
                "feature_module": "function_command_injection",
                "payloads": [
                    "; ls -la",
                    "| whoami",
                    "& cat /etc/passwd",
                ],
                "targets": ["form", "url_param"],
            }
        )

        # Path Traversal
        self._register_exploit(
            {
                "id": "path_traversal",
                "name": "Path Traversal",
                "type": ExploitType.PATH_TRAVERSAL,
                "severity": "high",
                "feature_module": "function_file_inclusion",
                "payloads": [
                    "../../../etc/passwd",
                    "..\\..\\..\\windows\\win.ini",
                    "....//....//....//etc/passwd",
                ],
                "targets": ["file_param", "url_param"],
            }
        )

        # IDOR
        self._register_exploit(
            {
                "id": "idor_basic",
                "name": "IDOR",
                "type": ExploitType.IDOR,
                "severity": "high",
                "feature_module": "function_idor",
                "payloads": [],  # IDOR 主要是邏輯測試
                "targets": ["api_endpoint", "id_param"],
            }
        )

        # Auth Bypass
        self._register_exploit(
            {
                "id": "auth_bypass",
                "name": "Authentication Bypass",
                "type": ExploitType.AUTH_BYPASS,
                "severity": "critical",
                "feature_module": "function_auth",
                "payloads": [],
                "targets": ["login", "admin_panel"],
            }
        )

        # JWT Attack
        self._register_exploit(
            {
                "id": "jwt_attack",
                "name": "JWT Token Attack",
                "type": ExploitType.JWT_ATTACK,
                "severity": "high",
                "feature_module": "function_jwt",
                "payloads": [],
                "targets": ["jwt_token", "auth_header"],
            }
        )

        # GraphQL Injection
        self._register_exploit(
            {
                "id": "graphql_injection",
                "name": "GraphQL Injection",
                "type": ExploitType.GRAPHQL_INJECTION,
                "severity": "medium",
                "feature_module": "function_graphql",
                "payloads": [
                    "{ __schema { types { name } } }",
                    "query { systemHealth }",
                ],
                "targets": ["graphql_endpoint"],
            }
        )

        logger.info(f"已註冊 {len(self.exploit_registry)} 個 exploit 定義")

    def _register_exploit(self, exploit: dict[str, Any]):
        """註冊漏洞利用定義"""
        exploit_id = exploit["id"]
        self.exploit_registry[exploit_id] = exploit
        self.execution_history[exploit_id] = []
        logger.debug(f"已註冊 exploit: {exploit_id}")

    def get_exploit(self, exploit_id: str) -> Optional[dict[str, Any]]:
        """獲取漏洞利用定義"""
        return self.exploit_registry.get(exploit_id)

    def get_all_exploits(self) -> dict[str, dict[str, Any]]:
        """獲取所有漏洞利用"""
        return self.exploit_registry.copy()

    def get_exploits_by_type(self, exploit_type: ExploitType) -> list[dict[str, Any]]:
        """根據類型獲取漏洞利用"""
        return [
            exploit
            for exploit in self.exploit_registry.values()
            if exploit["type"] == exploit_type
        ]

    def get_exploits_by_severity(self, severity: str) -> list[dict[str, Any]]:
        """根據嚴重程度獲取漏洞利用"""
        return [
            exploit
            for exploit in self.exploit_registry.values()
            if exploit["severity"] == severity
        ]

    async def orchestrate_exploit(
        self,
        exploit_id: str,
        target: dict[str, Any],
        parameters: dict[str, Any] | None = None,
    ) -> dict[str, Any]:
        """編排漏洞利用執行（不實際執行）
        
        返回執行計劃，由 MQ 發送給對應的 Feature 模組執行

        Args:
            exploit_id: 漏洞利用 ID
            target: 目標信息
            parameters: 執行參數

        Returns:
            執行計劃（待發送給 Features）
        """
        exploit = self.get_exploit(exploit_id)

        if not exploit:
            logger.error(f"未找到漏洞利用: {exploit_id}")
            return {
                "success": False,
                "error": f"Exploit not found: {exploit_id}",
            }

        logger.info(
            f"編排漏洞利用: {exploit_id}, target={target.get('url', 'unknown')}"
        )

        # 構建執行計劃
        execution_plan = {
            "action": "execute_exploit",
            "exploit_id": exploit_id,
            "exploit_name": exploit["name"],
            "exploit_type": exploit["type"].value,
            "severity": exploit["severity"],
            "feature_module": exploit.get("feature_module", "unknown"),
            "target": target,
            "parameters": parameters or {},
            "payloads": exploit["payloads"],
            "targets": exploit["targets"],
            "orchestrator": "ExploitOrchestrator",
            "timestamp": self._get_timestamp(),
        }

        # 記錄編排歷史
        self.execution_history[exploit_id].append({
            "target": target,
            "timestamp": execution_plan["timestamp"],
            "status": "planned",
        })

        logger.info(f"已生成執行計劃，待發送至 {exploit['feature_module']}")

        return {
            "success": True,
            "execution_plan": execution_plan,
            "message": f"Execution plan created for {exploit['feature_module']}",
        }

    def analyze_results(
        self,
        exploit_id: str,
        results: dict[str, Any],
    ) -> dict[str, Any]:
        """分析來自 Integration 的執行結果並做出決策
        
        Args:
            exploit_id: 漏洞利用 ID
            results: Features 執行後，Integration 收集的結果

        Returns:
            分析結果和下一步決策
        """
        exploit = self.get_exploit(exploit_id)
        
        if not exploit:
            return {
                "success": False,
                "error": f"Exploit not found: {exploit_id}",
            }

        # 更新執行歷史
        if exploit_id in self.execution_history:
            if self.execution_history[exploit_id]:
                self.execution_history[exploit_id][-1]["status"] = (
                    "completed" if results.get("success") else "failed"
                )
                self.execution_history[exploit_id][-1]["results"] = results

        # 分析結果
        vulnerable = results.get("vulnerable", False)
        severity = exploit["severity"]

        analysis = {
            "exploit_id": exploit_id,
            "exploit_name": exploit["name"],
            "exploit_type": exploit["type"].value,
            "vulnerable": vulnerable,
            "severity": severity,
            "risk_score": self._calculate_risk_score(severity, vulnerable),
            "results_summary": {
                "success": results.get("success", False),
                "payloads_tested": results.get("payloads_tested", 0),
                "findings": len(results.get("findings", [])),
            },
        }

        # 決策：是否需要進一步測試
        if vulnerable and severity in ["critical", "high"]:
            analysis["recommendation"] = "immediate_attention"
            analysis["next_steps"] = [
                "驗證漏洞可利用性",
                "評估影響範圍",
                "生成 PoC",
            ]
        elif vulnerable:
            analysis["recommendation"] = "further_testing"
            analysis["next_steps"] = ["深入測試", "收集更多證據"]
        else:
            analysis["recommendation"] = "continue_scanning"
            analysis["next_steps"] = ["測試其他漏洞類型"]

        logger.info(f"結果分析完成: {exploit_id}, vulnerable={vulnerable}")

        return analysis

    def _calculate_risk_score(self, severity: str, vulnerable: bool) -> int:
        """計算風險評分"""
        severity_scores = {
            "critical": 10,
            "high": 7,
            "medium": 4,
            "low": 2,
        }
        
        base_score = severity_scores.get(severity, 0)
        return base_score if vulnerable else 0

    def _get_timestamp(self) -> str:
        """獲取當前時間戳"""
        from datetime import datetime
        return datetime.utcnow().isoformat()

    def get_execution_history(self, exploit_id: str) -> list[dict[str, Any]]:
        """獲取執行歷史"""
        return self.execution_history.get(exploit_id, [])

    def get_statistics(self) -> dict[str, Any]:
        """獲取統計信息"""
        total_exploits = len(self.exploit_registry)
        total_executions = sum(
            len(history) for history in self.execution_history.values()
        )
        
        by_type = {}
        for exploit in self.exploit_registry.values():
            exploit_type = exploit["type"].value
            by_type[exploit_type] = by_type.get(exploit_type, 0) + 1

        return {
            "total_exploits": total_exploits,
            "total_orchestrations": total_executions,
            "exploits_by_type": by_type,
            "mode": "orchestration",
        }


# 向後兼容：保留 ExploitManager 別名
ExploitManager = ExploitOrchestrator
