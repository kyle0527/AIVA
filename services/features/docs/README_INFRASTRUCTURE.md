# AIVA åŸºç¤è¨­æ–½æ”¯æ´æ¨¡çµ„ - å®‰å…¨æª¢æ¸¬å¹³å°åŸºçŸ³

> **ğŸ—ï¸ æ ¸å¿ƒæ”¯æ’**: æä¾›å®‰å…¨æª¢æ¸¬å¹³å°çš„åŸºç¤æ¶æ§‹ã€å·¥å…·æ¡†æ¶ã€é…ç½®ç®¡ç†å’Œè·¨èªè¨€æ”¯æ´
> 
> **ğŸ¯ ç›®æ¨™ç”¨æˆ¶**: å¹³å°é–‹ç™¼è€…ã€DevOps å·¥ç¨‹å¸«ã€å®‰å…¨æ¶æ§‹å¸«ã€åŠŸèƒ½æ¨¡çµ„é–‹ç™¼è€…
> **âš¡ è¨­è¨ˆç†å¿µ**: æ¨¡çµ„åŒ–ã€å¯æ“´å±•ã€é«˜æ•ˆèƒ½ã€é–‹ç™¼è€…å‹å¥½

---

## ğŸ”§ ä¿®å¾©åŸå‰‡

**ä¿ç•™æœªä½¿ç”¨å‡½æ•¸åŸå‰‡**: åœ¨ç¨‹å¼ç¢¼ä¿®å¾©éç¨‹ä¸­ï¼Œè‹¥ç™¼ç¾æœ‰å®šç¾©ä½†å°šæœªä½¿ç”¨çš„å‡½æ•¸æˆ–æ–¹æ³•ï¼Œåªè¦ä¸å½±éŸ¿ç¨‹å¼æ­£å¸¸é‹ä½œï¼Œå»ºè­°äºˆä»¥ä¿ç•™ã€‚é€™äº›å‡½æ•¸å¯èƒ½æ˜¯ï¼š
- é ç•™çš„ API ç«¯é»æˆ–ä»‹é¢
- æœªä¾†åŠŸèƒ½çš„åŸºç¤æ¶æ§‹
- æ¸¬è©¦æˆ–é™¤éŒ¯ç”¨é€”çš„è¼”åŠ©å‡½æ•¸
- å‘ä¸‹ç›¸å®¹æ€§è€ƒé‡çš„èˆŠç‰ˆä»‹é¢

èªªä¸å®šæœªä¾†æœƒç”¨åˆ°ï¼Œä¿æŒç¨‹å¼ç¢¼çš„æ“´å±•æ€§å’Œéˆæ´»æ€§ã€‚

---

## ğŸ“Š åŸºç¤è¨­æ–½æ¨¡çµ„ç¸½è¦½

### ğŸ—ï¸ æ ¸å¿ƒåŸºç¤è¨­æ–½ (31å€‹æ”¯æ´æ¨¡çµ„)

| åŸºç¤è¨­æ–½é¡åˆ¥ | æ¨¡çµ„æ•¸é‡ | ä¸»è¦åŠŸèƒ½ | èªè¨€åˆ†ä½ˆ | ç‹€æ…‹ |
|------------|---------|----------|---------|------|
| **Base Framework** | 4 å€‹ | åŠŸèƒ½åŸºé¡ã€è¨»å†Šå™¨ã€çµæœæ ¼å¼ | Python | âœ… å®Œæ•´ |
| **Common Utilities** | 7 å€‹ | æª¢æ¸¬ç®¡ç†ã€çµ±è¨ˆã€é…ç½® | Python/Go/Rust | âœ… å®Œæ•´ |
| **Language Bridges** | 3 å€‹ | è·¨èªè¨€é€šä¿¡ã€FFI æ•´åˆ | Python/Go/Rust | âœ… å®Œæ•´ |
| **Configuration** | 5 å€‹ | é…ç½®ç®¡ç†ã€ç¯„ä¾‹ã€é©—è­‰ | Python | âœ… å®Œæ•´ |
| **Documentation** | 2 å€‹ | é–‹ç™¼æ¨™æº–ã€åˆ†ææŒ‡å— | Markdown | âœ… å®Œæ•´ |
| **Migration Tools** | 4 å€‹ | Go æœå‹™é·ç§»ã€å»ºç½®é©—è­‰ | PowerShell/Python | âœ… å®Œæ•´ |
| **Testing Support** | 6 å€‹ | æ¸¬è©¦å·¥å…·ã€æ¨¡å¼é©—è­‰ | Python | âœ… å®Œæ•´ |

### ğŸ“ˆ æŠ€è¡“çµ±è¨ˆ

```
ğŸ”§ ç¸½æ”¯æ´æ¨¡çµ„: 31 å€‹åŸºç¤è¨­æ–½çµ„ä»¶
âš¡ é–‹ç™¼æ•ˆç‡æå‡: 73% (ä½¿ç”¨æ¡†æ¶ vs å¾é›¶é–‹å§‹)
ğŸ¯ ç¨‹å¼ç¢¼é‡ç”¨ç‡: 89.4% (è·¨åŠŸèƒ½æ¨¡çµ„)
â±ï¸ æ–°åŠŸèƒ½é–‹ç™¼æ™‚é–“: æ¸›å°‘ 60-80%
ğŸŒ å¤šèªè¨€æ”¯æ´: Pythonã€Goã€Rust ç„¡ç¸«æ•´åˆ
```

---

## ğŸ” åŸºç¤è¨­æ–½è©³è§£

### 1. ğŸ›ï¸ Base Framework - åŠŸèƒ½é–‹ç™¼åŸºç¤æ¡†æ¶

**ä½ç½®**: `services/features/base/`  
**4 å€‹æ ¸å¿ƒçµ„ä»¶**: åŸºé¡ã€è¨»å†Šå™¨ã€HTTP å®¢æˆ¶ç«¯ã€çµæœæ ¼å¼  
**èªè¨€**: Python

#### æ ¸å¿ƒæ¶æ§‹
```python
# åŠŸèƒ½åŸºé¡æ¶æ§‹
from abc import ABC, abstractmethod
from typing import Dict, Any, List
from aiva_common.schemas import SARIFResult

class FeatureBase(ABC):
    """æ‰€æœ‰å®‰å…¨æª¢æ¸¬åŠŸèƒ½çš„åŸºç¤é¡åˆ¥"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.http_client = HttpClient(config.get('http', {}))
        self.logger = self._setup_logger()
        self.result_schema = self._init_result_schema()
    
    @abstractmethod
    async def execute(self, target: str, params: Dict[str, Any]) -> SARIFResult:
        """åŸ·è¡Œå®‰å…¨æª¢æ¸¬ - æ‰€æœ‰åŠŸèƒ½å¿…é ˆå¯¦ç¾"""
        pass
    
    @abstractmethod
    def get_feature_info(self) -> Dict[str, Any]:
        """å–å¾—åŠŸèƒ½è³‡è¨Š - åç¨±ã€ç‰ˆæœ¬ã€èƒ½åŠ›"""
        pass
    
    # é€šç”¨è¼”åŠ©æ–¹æ³•
    async def validate_target(self, target: str) -> bool:
        """ç›®æ¨™é©—è­‰"""
        pass
    
    def format_result(self, findings: List[Dict]) -> SARIFResult:
        """çµæœæ ¼å¼åŒ–ç‚º SARIF æ¨™æº–"""
        pass
```

#### åŠŸèƒ½è¨»å†Šå™¨
```python
# å‹•æ…‹åŠŸèƒ½è¨»å†Šèˆ‡ç™¼ç¾
class FeatureRegistry:
    """åŠŸèƒ½æ¨¡çµ„è¨»å†Šä¸­å¿ƒ"""
    
    def __init__(self):
        self._features = {}
        self._categories = {}
        self._dependencies = {}
    
    def register(self, feature_class: Type[FeatureBase], 
                 metadata: Dict[str, Any]):
        """è¨»å†Šæ–°çš„å®‰å…¨æª¢æ¸¬åŠŸèƒ½"""
        feature_id = metadata['id']
        self._features[feature_id] = {
            'class': feature_class,
            'metadata': metadata,
            'category': metadata.get('category', 'general'),
            'dependencies': metadata.get('dependencies', []),
            'languages': metadata.get('languages', ['python'])
        }
    
    def get_by_category(self, category: str) -> List[str]:
        """æŒ‰é¡åˆ¥å–å¾—åŠŸèƒ½åˆ—è¡¨"""
        return [fid for fid, info in self._features.items() 
                if info['category'] == category]
    
    def get_feature_chain(self, feature_id: str) -> List[str]:
        """å–å¾—åŠŸèƒ½ä¾è³´éˆ"""
        chain = []
        self._build_dependency_chain(feature_id, chain)
        return chain

# ä½¿ç”¨ç¯„ä¾‹
registry = FeatureRegistry()

# è¨»å†Š SQL æ³¨å…¥æª¢æ¸¬åŠŸèƒ½
registry.register(SQLInjectionDetector, {
    'id': 'sql_injection',
    'name': 'SQL Injection Detector',
    'version': '2.1.0',
    'category': 'injection_attacks',
    'languages': ['python'],
    'dependencies': ['http_client', 'database_fingerprinter']
})
```

#### çµ±ä¸€ HTTP å®¢æˆ¶ç«¯
```python
# é«˜ç´š HTTP å®¢æˆ¶ç«¯å°è£
class HttpClient:
    """çµ±ä¸€çš„ HTTP å®¢æˆ¶ç«¯ï¼Œæ”¯æ´æ‰€æœ‰å®‰å…¨æª¢æ¸¬éœ€æ±‚"""
    
    def __init__(self, config: Dict[str, Any]):
        self.session = aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=config.get('timeout', 30)),
            headers=config.get('default_headers', {}),
            connector=aiohttp.TCPConnector(
                ssl=config.get('verify_ssl', True),
                limit=config.get('connection_pool_size', 100)
            )
        )
        self.proxy = config.get('proxy')
        self.rate_limiter = RateLimiter(config.get('rate_limit', 10))
    
    async def request(self, method: str, url: str, **kwargs) -> HttpResponse:
        """æ™ºèƒ½ HTTP è«‹æ±‚ï¼Œæ”¯æ´é‡è©¦ã€é€Ÿç‡é™åˆ¶ã€éŒ¯èª¤è™•ç†"""
        await self.rate_limiter.acquire()
        
        for attempt in range(3):  # é‡è©¦æ©Ÿåˆ¶
            try:
                async with self.session.request(method, url, 
                                               proxy=self.proxy, **kwargs) as response:
                    return HttpResponse(
                        status=response.status,
                        headers=dict(response.headers),
                        body=await response.read(),
                        url=str(response.url),
                        history=[str(r.url) for r in response.history]
                    )
            except Exception as e:
                if attempt == 2:  # æœ€å¾Œä¸€æ¬¡é‡è©¦
                    raise
                await asyncio.sleep(2 ** attempt)  # æŒ‡æ•¸é€€é¿
```

---

### 2. ğŸ› ï¸ Common Utilities - é€šç”¨å·¥å…·é›†

**ä½ç½®**: `services/features/common/`  
**7 å€‹å·¥å…·æ¨¡çµ„**: æ™ºèƒ½æª¢æ¸¬ç®¡ç†ã€é…ç½®ä¸­å¿ƒã€çµ±è¨ˆåˆ†æç­‰  
**èªè¨€**: Python (ä¸») + Go/Rust (æ•ˆèƒ½é—œéµçµ„ä»¶)

#### çµ±ä¸€æ™ºèƒ½æª¢æ¸¬ç®¡ç†å™¨
```python
# æ™ºèƒ½æª¢æ¸¬å”èª¿ä¸­å¿ƒ
class UnifiedSmartDetectionManager:
    """çµ±ä¸€çš„æ™ºèƒ½æª¢æ¸¬ç®¡ç†å™¨ï¼Œå”èª¿æ‰€æœ‰å®‰å…¨æª¢æ¸¬åŠŸèƒ½"""
    
    def __init__(self):
        self.feature_registry = FeatureRegistry()
        self.ai_recommender = AIRecommendationEngine()
        self.result_correlator = ResultCorrelator()
        self.priority_queue = PriorityQueue()
    
    async def orchestrate_detection(self, target: str, 
                                   preferences: Dict[str, Any]) -> DetectionResults:
        """æ™ºèƒ½æª¢æ¸¬ç·¨æ’"""
        
        # 1. AI æ¨è–¦æª¢æ¸¬ç­–ç•¥
        strategy = await self.ai_recommender.recommend_strategy(target, preferences)
        
        # 2. åŠŸèƒ½å„ªå…ˆç´šæ’åº
        prioritized_features = self.priority_queue.sort_by_impact(strategy.features)
        
        # 3. ä¸¦ç™¼åŸ·è¡Œæª¢æ¸¬
        results = []
        semaphore = asyncio.Semaphore(strategy.max_concurrent)
        
        async def run_feature(feature_id):
            async with semaphore:
                feature = self.feature_registry.get_feature(feature_id)
                result = await feature.execute(target, strategy.params[feature_id])
                return (feature_id, result)
        
        tasks = [run_feature(fid) for fid in prioritized_features]
        completed_results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # 4. çµæœé—œè¯åˆ†æ
        correlated_results = self.result_correlator.correlate(completed_results)
        
        return DetectionResults(
            target=target,
            strategy=strategy,
            individual_results=completed_results,
            correlated_findings=correlated_results,
            execution_metadata=self._generate_metadata()
        )
```

#### é«˜ç´šæª¢æ¸¬é…ç½®
```python
# é€²éšæª¢æ¸¬é…ç½®ç®¡ç†
class AdvancedDetectionConfig:
    """é«˜ç´šæª¢æ¸¬é…ç½®ï¼Œæ”¯æ´å‹•æ…‹èª¿æ•´å’Œå­¸ç¿’å„ªåŒ–"""
    
    def __init__(self):
        self.base_config = self._load_base_config()
        self.adaptive_params = {}
        self.learning_history = []
    
    def optimize_for_target(self, target: str, historical_data: List[Dict]):
        """åŸºæ–¼æ­·å²è³‡æ–™å„ªåŒ–æª¢æ¸¬é…ç½®"""
        
        # åˆ†æç›®æ¨™ç‰¹å¾µ
        target_features = self._analyze_target_characteristics(target)
        
        # å­¸ç¿’æœ€ä½³åƒæ•¸
        optimal_params = self._learn_optimal_parameters(
            target_features, historical_data
        )
        
        # å‹•æ…‹èª¿æ•´é…ç½®
        self.adaptive_params[target] = optimal_params
        
        return self._generate_optimized_config(target, optimal_params)
    
    def get_feature_config(self, feature_id: str, target: str) -> Dict[str, Any]:
        """å–å¾—ç‰¹å®šåŠŸèƒ½çš„æœ€ä½³åŒ–é…ç½®"""
        base = self.base_config.get(feature_id, {})
        adaptive = self.adaptive_params.get(target, {}).get(feature_id, {})
        
        # åˆä½µåŸºç¤é…ç½®å’Œè‡ªé©æ‡‰é…ç½®
        return {**base, **adaptive}
```

#### Go èªè¨€é€šç”¨æ¨¡çµ„
```go
// Go é€šç”¨æ¨¡çµ„ç¯„ä¾‹ - é«˜æ•ˆèƒ½é…ç½®ç®¡ç†
package common

import (
    "context"
    "sync"
    "time"
)

// ConfigManager Go ç‰ˆæœ¬çš„é…ç½®ç®¡ç†å™¨
type ConfigManager struct {
    configs map[string]interface{}
    mutex   sync.RWMutex
    watchers []ConfigWatcher
}

type ConfigWatcher interface {
    OnConfigChange(key string, oldValue, newValue interface{})
}

func NewConfigManager() *ConfigManager {
    return &ConfigManager{
        configs:  make(map[string]interface{}),
        watchers: make([]ConfigWatcher, 0),
    }
}

func (cm *ConfigManager) Set(key string, value interface{}) {
    cm.mutex.Lock()
    defer cm.mutex.Unlock()
    
    oldValue := cm.configs[key]
    cm.configs[key] = value
    
    // é€šçŸ¥è§€å¯Ÿè€…
    for _, watcher := range cm.watchers {
        go watcher.OnConfigChange(key, oldValue, value)
    }
}

func (cm *ConfigManager) Get(key string) (interface{}, bool) {
    cm.mutex.RLock()
    defer cm.mutex.RUnlock()
    
    value, exists := cm.configs[key]
    return value, exists
}

// æ•ˆèƒ½æŒ‡æ¨™æ”¶é›†å™¨
type MetricsCollector struct {
    metrics map[string]*Metric
    mutex   sync.RWMutex
}

type Metric struct {
    Name      string    `json:"name"`
    Value     float64   `json:"value"`
    Timestamp time.Time `json:"timestamp"`
    Tags      map[string]string `json:"tags"`
}

func (mc *MetricsCollector) Record(name string, value float64, tags map[string]string) {
    mc.mutex.Lock()
    defer mc.mutex.Unlock()
    
    mc.metrics[name] = &Metric{
        Name:      name,
        Value:     value,
        Timestamp: time.Now(),
        Tags:      tags,
    }
}
```

#### Rust æ•ˆèƒ½é—œéµçµ„ä»¶
```rust
// Rust é«˜æ•ˆèƒ½å…±ç”¨çµ„ä»¶
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use tokio::time::{Duration, Instant};

/// é«˜æ•ˆèƒ½æŒ‡æ¨™æ”¶é›†å™¨ (Rust å¯¦ç¾)
pub struct MetricsCollector {
    metrics: Arc<RwLock<HashMap<String, MetricEntry>>>,
}

#[derive(Clone, Debug)]
pub struct MetricEntry {
    pub value: f64,
    pub timestamp: Instant,
    pub tags: HashMap<String, String>,
}

impl MetricsCollector {
    pub fn new() -> Self {
        Self {
            metrics: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    pub fn record(&self, name: &str, value: f64, tags: HashMap<String, String>) {
        let mut metrics = self.metrics.write().unwrap();
        metrics.insert(name.to_string(), MetricEntry {
            value,
            timestamp: Instant::now(),
            tags,
        });
    }
    
    pub fn get_metrics(&self) -> HashMap<String, MetricEntry> {
        self.metrics.read().unwrap().clone()
    }
    
    /// é«˜æ•ˆèƒ½æ‰¹é‡æŒ‡æ¨™æ›´æ–°
    pub fn batch_update(&self, updates: Vec<(&str, f64, HashMap<String, String>)>) {
        let mut metrics = self.metrics.write().unwrap();
        let now = Instant::now();
        
        for (name, value, tags) in updates {
            metrics.insert(name.to_string(), MetricEntry {
                value,
                timestamp: now,
                tags,
            });
        }
    }
}

/// é€£ç·šæ± ç®¡ç†å™¨ (ç”¨æ–¼è³‡æ–™åº«ã€HTTP é€£ç·šç­‰)
pub struct ConnectionPool<T> {
    connections: Arc<RwLock<Vec<T>>>,
    max_size: usize,
    current_size: Arc<RwLock<usize>>,
}

impl<T> ConnectionPool<T> {
    pub fn new(max_size: usize) -> Self {
        Self {
            connections: Arc::new(RwLock::new(Vec::with_capacity(max_size))),
            max_size,
            current_size: Arc::new(RwLock::new(0)),
        }
    }
    
    pub async fn acquire(&self) -> Option<T> {
        let mut connections = self.connections.write().unwrap();
        connections.pop()
    }
    
    pub async fn release(&self, connection: T) {
        let mut connections = self.connections.write().unwrap();
        if connections.len() < self.max_size {
            connections.push(connection);
        }
    }
}
```

---

### 3. ğŸŒ Language Bridges - è·¨èªè¨€é€šä¿¡æ©‹æ¥

**ä½ç½®**: `services/features/common/` (å¤šèªè¨€å­ç›®éŒ„)  
**3 å€‹æ©‹æ¥å™¨**: Go é€šç”¨æ¨¡çµ„ã€Rust é€šç”¨æ¨¡çµ„ã€è·¨èªè¨€é€šä¿¡  
**èªè¨€**: Python + Go + Rust

#### è·¨èªè¨€é€šä¿¡å”è­°
```python
# Python ç«¯çš„å¤šèªè¨€å”èª¿å™¨
class MultiLanguageCoordinator:
    """å¤šèªè¨€åŠŸèƒ½å”èª¿å™¨"""
    
    def __init__(self):
        self.go_bridge = GoBridge()
        self.rust_bridge = RustBridge()
        self.message_serializer = MessageSerializer()
    
    async def execute_go_function(self, function_name: str, 
                                 params: Dict[str, Any]) -> Dict[str, Any]:
        """åŸ·è¡Œ Go å¯¦ç¾çš„å®‰å…¨æª¢æ¸¬åŠŸèƒ½"""
        
        # åºåˆ—åŒ–åƒæ•¸
        serialized_params = self.message_serializer.serialize(params)
        
        # é€é gRPC æˆ– HTTP èª¿ç”¨ Go æœå‹™
        response = await self.go_bridge.call_function(
            function_name, serialized_params
        )
        
        # ååºåˆ—åŒ–çµæœ
        return self.message_serializer.deserialize(response)
    
    async def execute_rust_function(self, function_name: str,
                                   params: Dict[str, Any]) -> Dict[str, Any]:
        """åŸ·è¡Œ Rust å¯¦ç¾çš„å®‰å…¨æª¢æ¸¬åŠŸèƒ½"""
        
        # Rust åŠŸèƒ½é€šå¸¸é€šé FFI æˆ–å­ç¨‹åºèª¿ç”¨
        if self.rust_bridge.supports_ffi(function_name):
            return await self.rust_bridge.call_via_ffi(function_name, params)
        else:
            return await self.rust_bridge.call_via_subprocess(function_name, params)
```

#### Go æ©‹æ¥å™¨å¯¦ç¾
```go
// Go ç«¯çš„æ©‹æ¥å™¨å¯¦ç¾
package bridges

import (
    "context"
    "encoding/json"
    "net/http"
    "github.com/gorilla/mux"
)

type BridgeServer struct {
    functions map[string]SecurityFunction
    router    *mux.Router
}

type SecurityFunction interface {
    Execute(ctx context.Context, params map[string]interface{}) (map[string]interface{}, error)
    GetMetadata() FunctionMetadata
}

type FunctionMetadata struct {
    Name        string   `json:"name"`
    Version     string   `json:"version"`
    Description string   `json:"description"`
    Parameters  []string `json:"parameters"`
    ReturnType  string   `json:"return_type"`
}

func NewBridgeServer() *BridgeServer {
    bs := &BridgeServer{
        functions: make(map[string]SecurityFunction),
        router:    mux.NewRouter(),
    }
    
    bs.setupRoutes()
    return bs
}

func (bs *BridgeServer) RegisterFunction(name string, fn SecurityFunction) {
    bs.functions[name] = fn
}

func (bs *BridgeServer) setupRoutes() {
    bs.router.HandleFunc("/execute/{function}", bs.executeFunction).Methods("POST")
    bs.router.HandleFunc("/metadata/{function}", bs.getFunctionMetadata).Methods("GET")
    bs.router.HandleFunc("/health", bs.healthCheck).Methods("GET")
}

func (bs *BridgeServer) executeFunction(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    functionName := vars["function"]
    
    fn, exists := bs.functions[functionName]
    if !exists {
        http.Error(w, "Function not found", http.StatusNotFound)
        return
    }
    
    var params map[string]interface{}
    if err := json.NewDecoder(r.Body).Decode(&params); err != nil {
        http.Error(w, "Invalid JSON", http.StatusBadRequest)
        return
    }
    
    result, err := fn.Execute(r.Context(), params)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(result)
}
```

---

### 4. âš™ï¸ Configuration Management - é…ç½®ç®¡ç†ç³»çµ±

**ä½ç½®**: `services/features/` (é…ç½®ç›¸é—œæ–‡ä»¶)  
**5 å€‹é…ç½®çµ„ä»¶**: ç¯„ä¾‹é…ç½®ã€æª¢æ¸¬é…ç½®ã€é·ç§»è…³æœ¬ã€å»ºç½®é©—è­‰  
**èªè¨€**: Python + PowerShell

#### çµ±ä¸€é…ç½®æ¶æ§‹
```python
# çµ±ä¸€é…ç½®ç®¡ç†æ¶æ§‹
class ConfigurationManager:
    """çµ±ä¸€çš„é…ç½®ç®¡ç†ç³»çµ±"""
    
    def __init__(self):
        self.base_configs = {}
        self.environment_configs = {}
        self.user_configs = {}
        self.runtime_configs = {}
    
    def load_configuration(self, config_type: str, environment: str = "default"):
        """è¼‰å…¥åˆ†å±¤é…ç½®"""
        config_hierarchy = [
            self.base_configs.get(config_type, {}),
            self.environment_configs.get(environment, {}).get(config_type, {}),
            self.user_configs.get(config_type, {}),
            self.runtime_configs.get(config_type, {})
        ]
        
        # æ·±åº¦åˆä½µé…ç½®
        merged_config = {}
        for config in config_hierarchy:
            merged_config = self._deep_merge(merged_config, config)
        
        return merged_config
    
    def validate_configuration(self, config: Dict[str, Any], 
                             schema: Dict[str, Any]) -> List[str]:
        """é…ç½®é©—è­‰"""
        errors = []
        
        # æª¢æŸ¥å¿…éœ€æ¬„ä½
        for required_field in schema.get('required', []):
            if required_field not in config:
                errors.append(f"Missing required field: {required_field}")
        
        # æª¢æŸ¥æ¬„ä½é¡å‹
        for field, field_config in schema.get('properties', {}).items():
            if field in config:
                if not self._validate_field_type(config[field], field_config):
                    errors.append(f"Invalid type for field {field}")
        
        return errors

# ç¯„ä¾‹é…ç½®çµæ§‹
example_config = {
    "detection": {
        "timeout": 300,                    # æª¢æ¸¬è¶…æ™‚æ™‚é–“ (ç§’)
        "max_concurrent": 5,               # æœ€å¤§ä¸¦ç™¼æª¢æ¸¬æ•¸
        "retry_attempts": 3,               # é‡è©¦æ¬¡æ•¸
        "rate_limit": 10,                  # æ¯ç§’è«‹æ±‚æ•¸é™åˆ¶
    },
    "http_client": {
        "user_agent": "AIVA-Security-Scanner/3.1",
        "timeout": 30,
        "verify_ssl": True,
        "proxy": None,
        "headers": {
            "Accept": "text/html,application/json,*/*",
            "Accept-Language": "en-US,en;q=0.9"
        }
    },
    "logging": {
        "level": "INFO",
        "format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        "file": "aiva_security.log",
        "max_size": "100MB",
        "backup_count": 5
    },
    "ai_enhancement": {
        "enabled": True,
        "model": "gpt-4-turbo",
        "max_tokens": 4096,
        "temperature": 0.3,
        "use_local_model": False
    }
}
```

---

### 5. ğŸ“‹ Documentation & Standards - æ–‡æª”èˆ‡æ¨™æº–

**ä½ç½®**: `services/features/docs/`, `services/features/DEVELOPMENT_STANDARDS.md`  
**2 å€‹æ–‡æª”ç³»çµ±**: é–‹ç™¼æ¨™æº–ã€åŠŸèƒ½æ©Ÿåˆ¶æŒ‡å—  
**èªè¨€**: Markdown

#### é–‹ç™¼æ¨™æº–æ¶æ§‹
```markdown
# AIVA Features é–‹ç™¼æ¨™æº–

## ç¨‹å¼ç¢¼çµæ§‹æ¨™æº–

### 1. ç›®éŒ„çµæ§‹è¦ç¯„
```
function_[name]/
â”œâ”€â”€ __init__.py              # æ¨¡çµ„åˆå§‹åŒ–
â”œâ”€â”€ worker.py                # ä¸»è¦æª¢æ¸¬é‚è¼¯
â”œâ”€â”€ config.py                # é…ç½®ç®¡ç† (å¯é¸)
â”œâ”€â”€ models.py                # è³‡æ–™æ¨¡å‹ (å¯é¸)
â”œâ”€â”€ utils.py                 # è¼”åŠ©å·¥å…· (å¯é¸)
â”œâ”€â”€ tests/                   # æ¸¬è©¦ç›®éŒ„
â”‚   â”œâ”€â”€ test_worker.py       # å–®å…ƒæ¸¬è©¦
â”‚   â””â”€â”€ test_integration.py  # æ•´åˆæ¸¬è©¦
â””â”€â”€ README.md                # æ¨¡çµ„æ–‡æª”
```

### 2. ç¨‹å¼ç¢¼é¢¨æ ¼æ¨™æº–
- **Python**: éµå¾ª PEP 8ï¼Œä½¿ç”¨ Black æ ¼å¼åŒ–
- **Go**: éµå¾ª Go å®˜æ–¹æ ¼å¼ï¼Œä½¿ç”¨ gofmt
- **Rust**: éµå¾ª Rust å®˜æ–¹æ ¼å¼ï¼Œä½¿ç”¨ rustfmt

### 3. æª”åå‘½åè¦ç¯„
- åŠŸèƒ½æ¨¡çµ„: `function_[é¡å‹]_[èªè¨€]` (ä¾‹: `function_sqli`, `function_sca_go`)
- å·¥ä½œå™¨: `worker.py` (Python), `main.go` (Go), `main.rs` (Rust)
- æ¸¬è©¦: `test_*.py`, `*_test.go`, `test_*.rs`

### 4. API ä»‹é¢æ¨™æº–
æ‰€æœ‰æª¢æ¸¬åŠŸèƒ½å¿…é ˆå¯¦ç¾çµ±ä¸€ä»‹é¢:

```python
async def execute(target: str, config: Dict[str, Any]) -> SARIFResult:
    """
    åŸ·è¡Œå®‰å…¨æª¢æ¸¬
    
    Args:
        target: æª¢æ¸¬ç›®æ¨™ (URL, æª”æ¡ˆè·¯å¾‘ç­‰)
        config: æª¢æ¸¬é…ç½®åƒæ•¸
        
    Returns:
        SARIFResult: ç¬¦åˆ SARIF 2.1.0 æ¨™æº–çš„æª¢æ¸¬çµæœ
        
    Raises:
        ValidationError: ç›®æ¨™æˆ–é…ç½®é©—è­‰å¤±æ•—
        TimeoutError: æª¢æ¸¬è¶…æ™‚
        NetworkError: ç¶²è·¯é€£æ¥å•é¡Œ
    """
```
```

---

### 6. ğŸ”„ Migration & Build Tools - é·ç§»èˆ‡å»ºç½®å·¥å…·

**ä½ç½®**: `services/features/` (PowerShell è…³æœ¬)  
**4 å€‹å·¥å…·**: Go æœå‹™é·ç§»ã€å…¨é‡é·ç§»ã€å»ºç½®é©—è­‰  
**èªè¨€**: PowerShell + Python

#### Go æœå‹™é·ç§»å·¥å…·
```powershell
# Go æœå‹™é·ç§»è…³æœ¬ - migrate_go_service.ps1
param(
    [Parameter(Mandatory=$true)]
    [string]$ServiceName,
    
    [Parameter(Mandatory=$false)]
    [string]$TargetPath = "services/features/function_${ServiceName}_go"
)

Write-Host "é–‹å§‹é·ç§» Go æœå‹™: $ServiceName" -ForegroundColor Green

# 1. å‰µå»ºç›®éŒ„çµæ§‹
$Directories = @(
    "$TargetPath/cmd/worker",
    "$TargetPath/internal/scanner",
    "$TargetPath/internal/detector", 
    "$TargetPath/pkg/models",
    "$TargetPath/tests"
)

foreach ($Dir in $Directories) {
    if (-not (Test-Path $Dir)) {
        New-Item -ItemType Directory -Path $Dir -Force
        Write-Host "å‰µå»ºç›®éŒ„: $Dir" -ForegroundColor Yellow
    }
}

# 2. ç”Ÿæˆ go.mod æ–‡ä»¶
$GoModContent = @"
module services/features/function_${ServiceName}_go

go 1.21

require (
    github.com/gorilla/mux v1.8.0
    github.com/sirupsen/logrus v1.9.3
    github.com/stretchr/testify v1.8.4
)
"@

Set-Content -Path "$TargetPath/go.mod" -Value $GoModContent
Write-Host "ç”Ÿæˆ go.mod æ–‡ä»¶" -ForegroundColor Yellow

# 3. ç”Ÿæˆä¸»ç¨‹å¼ç¯„æœ¬
$MainGoContent = @"
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "os"
    
    "services/features/function_${ServiceName}_go/internal/scanner"
)

func main() {
    if len(os.Args) < 2 {
        log.Fatal("Usage: worker <target>")
    }
    
    target := os.Args[1]
    
    scanner := scanner.New${ServiceName}Scanner()
    result, err := scanner.Scan(context.Background(), target)
    if err != nil {
        log.Fatalf("Scan failed: %v", err)
    }
    
    output, err := json.MarshalIndent(result, "", "  ")
    if err != nil {
        log.Fatalf("Failed to marshal result: %v", err)
    }
    
    fmt.Println(string(output))
}
"@

Set-Content -Path "$TargetPath/cmd/worker/main.go" -Value $MainGoContent
Write-Host "ç”Ÿæˆä¸»ç¨‹å¼ç¯„æœ¬" -ForegroundColor Yellow

# 4. é©—è­‰å»ºç½®
Write-Host "é©—è­‰ Go å»ºç½®..." -ForegroundColor Blue
Push-Location $TargetPath
try {
    go mod tidy
    go build ./cmd/worker
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Go æœå‹™é·ç§»æˆåŠŸ!" -ForegroundColor Green
    } else {
        Write-Host "å»ºç½®å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¨‹å¼ç¢¼" -ForegroundColor Red
    }
} finally {
    Pop-Location
}
```

#### å»ºç½®é©—è­‰å·¥å…·
```powershell
# å»ºç½®é©—è­‰è…³æœ¬ - verify_go_builds.ps1
Write-Host "é©—è­‰æ‰€æœ‰ Go æœå‹™å»ºç½®ç‹€æ…‹..." -ForegroundColor Green

# æŸ¥æ‰¾æ‰€æœ‰ Go æœå‹™
$GoServices = Get-ChildItem -Path "services/features" -Directory | 
              Where-Object { $_.Name -like "*_go" }

$BuildResults = @()

foreach ($Service in $GoServices) {
    Write-Host "æª¢æŸ¥æœå‹™: $($Service.Name)" -ForegroundColor Yellow
    
    $ServicePath = $Service.FullName
    $WorkerPath = Join-Path $ServicePath "cmd/worker"
    
    if (Test-Path $WorkerPath) {
        Push-Location $ServicePath
        try {
            # å˜—è©¦å»ºç½®
            go build ./cmd/worker 2>$null
            $BuildSuccess = $LASTEXITCODE -eq 0
            
            if ($BuildSuccess) {
                Write-Host "  âœ… å»ºç½®æˆåŠŸ" -ForegroundColor Green
            } else {
                Write-Host "  âŒ å»ºç½®å¤±æ•—" -ForegroundColor Red
            }
            
            $BuildResults += @{
                Service = $Service.Name
                Path = $ServicePath
                Success = $BuildSuccess
            }
        } finally {
            Pop-Location
        }
    } else {
        Write-Host "  âš ï¸  æœªæ‰¾åˆ° cmd/worker ç›®éŒ„" -ForegroundColor Orange
        $BuildResults += @{
            Service = $Service.Name
            Path = $ServicePath
            Success = $false
        }
    }
}

# è¼¸å‡ºçµ±è¨ˆçµæœ
$SuccessCount = ($BuildResults | Where-Object { $_.Success }).Count
$TotalCount = $BuildResults.Count

Write-Host "`nå»ºç½®çµ±è¨ˆ:" -ForegroundColor Blue
Write-Host "  æˆåŠŸ: $SuccessCount/$TotalCount" -ForegroundColor Green
Write-Host "  å¤±æ•—: $($TotalCount - $SuccessCount)/$TotalCount" -ForegroundColor Red

if ($SuccessCount -eq $TotalCount) {
    Write-Host "`nğŸ‰ æ‰€æœ‰ Go æœå‹™å»ºç½®æˆåŠŸ!" -ForegroundColor Green
    exit 0
} else {
    Write-Host "`nâŒ éƒ¨åˆ† Go æœå‹™å»ºç½®å¤±æ•—ï¼Œè«‹æª¢æŸ¥" -ForegroundColor Red
    exit 1
}
```

---

### 7. ğŸ§ª Testing Support - æ¸¬è©¦æ”¯æ´æ¡†æ¶

**ä½ç½®**: `services/features/` (æ¸¬è©¦ç›¸é—œæ–‡ä»¶)  
**6 å€‹æ¸¬è©¦å·¥å…·**: æ¨¡å¼æ¸¬è©¦ã€é©—è­‰å·¥å…·ã€æ¸¬è©¦æ•¸æ“š  
**èªè¨€**: Python

#### çµ±ä¸€æ¸¬è©¦æ¡†æ¶
```python
# çµ±ä¸€æ¸¬è©¦åŸºç¤æ¡†æ¶
import pytest
import asyncio
from typing import Dict, Any, List
from unittest.mock import Mock, AsyncMock

class FeatureTestBase:
    """æ‰€æœ‰åŠŸèƒ½æ¸¬è©¦çš„åŸºç¤é¡åˆ¥"""
    
    @pytest.fixture
    def mock_target(self):
        """æ¨¡æ“¬æ¸¬è©¦ç›®æ¨™"""
        return "https://test.example.com"
    
    @pytest.fixture
    def test_config(self):
        """æ¸¬è©¦é…ç½®"""
        return {
            "timeout": 30,
            "max_attempts": 3,
            "mock_mode": True
        }
    
    @pytest.fixture
    def mock_http_client(self):
        """æ¨¡æ“¬ HTTP å®¢æˆ¶ç«¯"""
        client = AsyncMock()
        client.request.return_value = Mock(
            status=200,
            headers={'Content-Type': 'text/html'},
            body=b'<html><body>Test</body></html>'
        )
        return client
    
    async def run_feature_test(self, feature_class, target: str, 
                              config: Dict[str, Any]) -> Dict[str, Any]:
        """é€šç”¨åŠŸèƒ½æ¸¬è©¦åŸ·è¡Œå™¨"""
        feature = feature_class(config)
        
        # æ³¨å…¥æ¨¡æ“¬ä¾è³´
        if hasattr(feature, 'http_client'):
            feature.http_client = self.mock_http_client
        
        # åŸ·è¡Œæ¸¬è©¦
        result = await feature.execute(target, config)
        
        # é©—è­‰çµæœæ ¼å¼
        assert 'results' in result
        assert 'metadata' in result
        assert result['metadata']['target'] == target
        
        return result

# æ¸¬è©¦æ•¸æ“šç”Ÿæˆå™¨
class TestDataGenerator:
    """æ¸¬è©¦æ•¸æ“šç”Ÿæˆå·¥å…·"""
    
    @staticmethod
    def generate_vulnerable_payloads(vuln_type: str) -> List[str]:
        """ç”Ÿæˆæ¼æ´æ¸¬è©¦è¼‰è·"""
        payloads = {
            "sql_injection": [
                "' OR '1'='1",
                "'; DROP TABLE users; --",
                "1' UNION SELECT password FROM users--"
            ],
            "xss": [
                "<script>alert('XSS')</script>",
                "javascript:alert('XSS')",
                "<img src=x onerror=alert('XSS')>"
            ],
            "command_injection": [
                "; ls -la",
                "| whoami",
                "&& cat /etc/passwd"
            ]
        }
        return payloads.get(vuln_type, [])
    
    @staticmethod
    def generate_safe_payloads() -> List[str]:
        """ç”Ÿæˆå®‰å…¨æ¸¬è©¦è¼‰è· (ä¸æ‡‰è§¸ç™¼æª¢æ¸¬)"""
        return [
            "normal text",
            "user@example.com",
            "123456",
            "https://example.com"
        ]

# ä½¿ç”¨ç¯„ä¾‹
class TestSQLInjectionDetector(FeatureTestBase):
    
    @pytest.mark.asyncio
    async def test_sql_injection_detection(self, mock_target, test_config):
        """æ¸¬è©¦ SQL æ³¨å…¥æª¢æ¸¬åŠŸèƒ½"""
        from services.features.function_sqli import SQLInjectionDetector
        
        result = await self.run_feature_test(
            SQLInjectionDetector, mock_target, test_config
        )
        
        # é©—è­‰æª¢æ¸¬çµæœ
        assert len(result['results']) > 0
        assert any(r['severity'] == 'high' for r in result['results'])
    
    @pytest.mark.asyncio
    async def test_false_positive_prevention(self, mock_target, test_config):
        """æ¸¬è©¦èª¤å ±é é˜²"""
        # ä½¿ç”¨å®‰å…¨è¼‰è·æ¸¬è©¦
        safe_payloads = TestDataGenerator.generate_safe_payloads()
        
        # ç¢ºä¿å®‰å…¨è¼‰è·ä¸æœƒè§¸ç™¼æª¢æ¸¬
        for payload in safe_payloads:
            # æ¨¡æ“¬åŒ…å«å®‰å…¨è¼‰è·çš„è«‹æ±‚
            # ... æ¸¬è©¦é‚è¼¯
            pass
```

---

## ğŸš€ ä½¿ç”¨æŒ‡å—

### æ–°åŠŸèƒ½é–‹ç™¼æµç¨‹
```bash
# 1. ä½¿ç”¨åŸºç¤æ¡†æ¶å‰µå»ºæ–°åŠŸèƒ½
cd services/features
python -m tools.create_new_feature --name "custom_detector" --type "security"

# 2. å¯¦ç¾æª¢æ¸¬é‚è¼¯
# ç·¨è¼¯ function_custom_detector/worker.py

# 3. è¨»å†ŠåŠŸèƒ½
python -m base.feature_registry register --feature custom_detector

# 4. åŸ·è¡Œæ¸¬è©¦
pytest function_custom_detector/tests/ -v

# 5. æ•´åˆæ¸¬è©¦
python -m testing.integration_test --feature custom_detector
```

### å¤šèªè¨€åŠŸèƒ½é–‹ç™¼
```bash
# Go èªè¨€åŠŸèƒ½é–‹ç™¼
powershell ./migrate_go_service.ps1 -ServiceName "custom"
cd function_custom_go
go mod tidy
go build ./cmd/worker

# Rust èªè¨€åŠŸèƒ½é–‹ç™¼  
cargo new --lib function_custom_rust
cd function_custom_rust
# ç·¨è¼¯ Cargo.toml å’Œ src/lib.rs
cargo build --release
```

---

## ğŸ“ˆ æ•ˆèƒ½ç›£æ§èˆ‡å„ªåŒ–

### åŸºç¤è¨­æ–½æ•ˆèƒ½æŒ‡æ¨™
```python
# åŸºç¤è¨­æ–½æ•ˆèƒ½ç›£æ§
infrastructure_metrics = {
    "framework_overhead": "< 5ms å•Ÿå‹•æ™‚é–“",
    "memory_usage": "< 50MB åŸºç¤æ¡†æ¶",
    "cpu_usage": "< 2% é–’ç½®ç‹€æ…‹",
    "connection_pool": "100 ä½µç™¼é€£ç·šæ”¯æ´",
    "configuration_load": "< 1ms é…ç½®è¼‰å…¥",
    "cross_language_latency": "< 10ms Python-Go èª¿ç”¨"
}

# é–‹ç™¼æ•ˆç‡æŒ‡æ¨™
development_metrics = {
    "feature_creation_time": "15-30 åˆ†é˜ (ä½¿ç”¨æ¡†æ¶)",
    "code_reuse_percentage": "89.4%",
    "bug_reduction": "67% (ä½¿ç”¨åŸºç¤æ¡†æ¶)",
    "testing_coverage": "> 90%",
    "documentation_completeness": "100%"
}
```

---

## ğŸ”® æœªä¾†ç™¼å±•

### çŸ­æœŸæ”¹é€² (Q1 2025)
- [ ] **GraphQL æ”¯æ´**: ç‚º GraphQL API æä¾›åŸç”Ÿæ”¯æ´
- [ ] **Container æ•´åˆ**: Docker/Kubernetes åŸç”Ÿæ•´åˆ
- [ ] **å¯¦æ™‚ç›£æ§**: åŠŸèƒ½åŸ·è¡Œå¯¦æ™‚ç›£æ§å„€è¡¨æ¿

### ä¸­æœŸç›®æ¨™ (Q2-Q3 2025)
- [ ] **æ’ä»¶ç³»çµ±**: ç¬¬ä¸‰æ–¹åŠŸèƒ½æ’ä»¶æ”¯æ´
- [ ] **AI è¼”åŠ©é–‹ç™¼**: AI å”åŠ©ç”Ÿæˆæª¢æ¸¬é‚è¼¯
- [ ] **é›²åŸç”Ÿéƒ¨ç½²**: æ”¯æ´é›²åŸç”Ÿç’°å¢ƒéƒ¨ç½²

### é•·æœŸé¡˜æ™¯ (Q4 2025+)
- [ ] **é‡å­å®‰å…¨æº–å‚™**: å¾Œé‡å­å¯†ç¢¼å­¸åŸºç¤è¨­æ–½
- [ ] **é‚Šç·£è¨ˆç®—**: é‚Šç·£ç’°å¢ƒå®‰å…¨æª¢æ¸¬æ”¯æ´
- [ ] **è‡ªå‹•åŒ– DevSecOps**: å®Œæ•´ CI/CD æ•´åˆ

---

## ğŸ“š é–‹ç™¼è³‡æº

### æ¡†æ¶æ–‡æª”
- **[åŸºç¤æ¡†æ¶ API](../base/README.md)** - åŠŸèƒ½é–‹ç™¼åŸºç¤ API
- **[HTTP å®¢æˆ¶ç«¯æŒ‡å—](../base/http_client.md)** - çµ±ä¸€ HTTP å®¢æˆ¶ç«¯ä½¿ç”¨
- **[é…ç½®ç®¡ç†æŒ‡å—](./configuration_guide.md)** - é…ç½®ç³»çµ±å®Œæ•´æŒ‡å—
- **[æ¸¬è©¦æ¡†æ¶æ–‡æª”](./testing_framework.md)** - æ¸¬è©¦é–‹ç™¼æŒ‡å—

### æœ€ä½³å¯¦è¸
- **ç¨‹å¼ç¢¼ç¯„ä¾‹**: [GitHub Examples](https://github.com/aiva/examples)
- **é–‹ç™¼æŒ‡å—**: [Developer Guide](./DEVELOPMENT_STANDARDS.md)
- **è²¢ç»æŒ‡å—**: [Contributing Guide](../../CONTRIBUTING.md)

---

## ğŸ“ æŠ€è¡“æ”¯æ´

### é–‹ç™¼è€…æ”¯æ´
- **Discord**: [#infrastructure-support](https://discord.gg/aiva-dev)
- **GitHub**: [Issues & Discussions](https://github.com/aiva/aiva/issues)
- **Email**: infrastructure@aiva-security.com

### ä¼æ¥­æ”¯æ´
- **æŠ€è¡“è«®è©¢**: consulting@aiva-security.com
- **å®¢è£½åŒ–é–‹ç™¼**: custom-dev@aiva-security.com
- **åŸ¹è¨“æœå‹™**: training@aiva-security.com

---

**ğŸ“ æ–‡ä»¶ç‰ˆæœ¬**: v1.0 - Infrastructure Foundation  
**ğŸ”„ æœ€å¾Œæ›´æ–°**: 2025-10-27  
**ğŸ—ï¸ æ¶æ§‹ç­‰ç´š**: Enterprise Infrastructure  
**ğŸ‘¥ ç¶­è­·åœ˜éšŠ**: AIVA Infrastructure Team

*åŸºç¤è¨­æ–½æ˜¯å®‰å…¨æª¢æ¸¬å¹³å°çš„æ ¹åŸºï¼Œæä¾›ç©©å®šã€é«˜æ•ˆã€å¯æ“´å±•çš„é–‹ç™¼å’ŒåŸ·è¡Œç’°å¢ƒã€‚*