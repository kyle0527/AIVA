#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""AIVA 實戰滲透測試執行器 - 真實目標測試"""

import sys
import asyncio
import json
import uuid
from datetime import datetime
from typing import List, Dict, Any
import aiohttp

sys.path.append('services')

from services.features.function_xss.payload_generator import XssPayloadGenerator
from services.features.function_xss.dom_xss_detector import DomXssDetector
from services.aiva_common.enums import Severity, Confidence, VulnerabilityType
from services.aiva_common.schemas import FindingPayload, Vulnerability, Target

class LivePentestRunner:
    """實戰滲透測試執行器"""
    
    def __init__(self):
        self.xss_generator = XssPayloadGenerator()
        self.xss_detector = DomXssDetector()
        self.findings = []
        self.session_id = f"pentest_{uuid.uuid4().hex[:8]}"
        
    async def test_xss_vulnerability(self, target_url: str, parameters: List[str]) -> List[Dict]:
        """對目標進行 XSS 漏洞測試"""
        findings = []
        payloads = self.xss_generator.generate_basic_payloads()
        
        print(f"\n[INFO] 開始對 {target_url} 進行 XSS 測試")
        print(f"[INFO] 測試參數: {parameters}")
        print(f"[INFO] 使用 {len(payloads)} 個 XSS Payload")
        
        async with aiohttp.ClientSession() as session:
            for param in parameters:
                for i, payload in enumerate(payloads, 1):
                    # 在 try 塊外初始化 test_url 以解決變數綁定問題
                    test_url: str | None = None
                    try:
                        # 構造測試 URL
                        test_url = f"{target_url}?{param}={payload}"
                        
                        print(f"[TEST] Payload {i}/{len(payloads)}: {param}={payload[:50]}...")
                        
                        # 發送請求
                        async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=10)) as response:
                            html_content = await response.text()
                            
                            # 使用 DomXssDetector 分析回應
                            detection_result = self.xss_detector.analyze(
                                payload=payload,
                                document=html_content
                            )
                            
                            if detection_result:
                                # 發現潛在 XSS 漏洞
                                vulnerability = Vulnerability(
                                    name=VulnerabilityType.XSS,
                                    severity=Severity.HIGH,
                                    confidence=Confidence.FIRM,
                                    description=f"Potential XSS vulnerability detected with payload: {payload}",
                                    cwe="CWE-79",
                                    cvss_score=7.2
                                )
                                
                                target_info = Target(
                                    url=test_url,
                                    parameter=param,
                                    method="GET"
                                )
                                
                                finding = FindingPayload(
                                    finding_id=f"finding_{self.session_id}_{len(findings)+1:03d}",
                                    task_id=f"task_{self.session_id}",
                                    scan_id=f"scan_{self.session_id}",
                                    status="confirmed",
                                    vulnerability=vulnerability,
                                    target=target_info,
                                    strategy="DOM-based XSS detection"
                                )
                                
                                findings.append({
                                    'finding': finding,
                                    'payload': payload,
                                    'response_length': len(html_content),
                                    'detection_details': detection_result
                                })
                                
                                print(f"[VULN] 發現 XSS 漏洞！Payload: {payload}")
                                print(f"       目標: {test_url}")
                                print(f"       檢測詳情: {detection_result}")
                            else:
                                print(f"[SAFE] 無漏洞檢測到")
                                
                    except asyncio.TimeoutError:
                        print(f"[TIMEOUT] 請求超時: {test_url or 'Unknown URL'}")
                    except Exception as e:
                        print(f"[ERROR] 測試錯誤: {e}")
                        
        return findings
    
    async def test_parameter_pollution(self, target_url: str) -> List[Dict]:
        """測試 HTTP 參數汙染漏洞"""
        findings = []
        
        print(f"\n[INFO] 開始對 {target_url} 進行參數汙染測試")
        
        # 參數汙染測試 Payload
        pollution_tests = [
            {'param1': 'value1', 'param1': 'value2'},  # 重複參數
            {'user': 'admin', 'user': 'guest'},        # 身份混淆
            {'id': '1', 'id': '2'},                     # ID 混淆
        ]
        
        async with aiohttp.ClientSession() as session:
            for i, test_params in enumerate(pollution_tests, 1):
                try:
                    print(f"[TEST] 汙染測試 {i}: {test_params}")
                    
                    async with session.get(target_url, params=test_params, timeout=aiohttp.ClientTimeout(total=10)) as response:
                        content = await response.text()
                        
                        # 簡單檢測：如果回應包含兩個值，可能存在參數汙染
                        param_values = list(test_params.values())
                        if len(set(param_values)) > 1 and all(val in content for val in param_values):
                            print(f"[VULN] 疑似參數汙染漏洞")
                            findings.append({
                                'type': 'parameter_pollution',
                                'url': target_url,
                                'params': test_params,
                                'response_length': len(content)
                            })
                        else:
                            print(f"[SAFE] 無參數汙染檢測到")
                            
                except Exception as e:
                    print(f"[ERROR] 參數汙染測試錯誤: {e}")
                    
        return findings
    
    async def run_comprehensive_test(self):
        """執行綜合滲透測試"""
        print("=" * 70)
        print("AIVA 實戰滲透測試開始")
        print(f"測試會話 ID: {self.session_id}")
        print(f"開始時間: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("=" * 70)
        
        # 測試目標配置
        test_targets = [
            {
                'name': 'HTTPBin',
                'url': 'https://httpbin.org/get',
                'params': ['q', 'search', 'input', 'data']
            },
            {
                'name': 'JSONPlaceholder',
                'url': 'https://jsonplaceholder.typicode.com/posts',
                'params': ['title', 'body', 'userId']
            },
            {
                'name': 'ReqRes API',
                'url': 'https://reqres.in/api/users',
                'params': ['page', 'per_page', 'delay']
            }
        ]
        
        all_findings = []
        
        for target in test_targets:
            print(f"\n{'='*50}")
            print(f"測試目標: {target['name']}")
            print(f"URL: {target['url']}")
            print(f"{'='*50}")
            
            # 1. XSS 漏洞測試
            xss_findings = await self.test_xss_vulnerability(
                target['url'], 
                target['params']
            )
            all_findings.extend(xss_findings)
            
            # 2. 參數汙染測試
            pollution_findings = await self.test_parameter_pollution(target['url'])
            all_findings.extend(pollution_findings)
            
            # 等待間隔，避免過於頻繁的請求
            await asyncio.sleep(2)
        
        # 生成測試報告
        await self.generate_report(all_findings)
        
    async def generate_report(self, findings: List[Dict]):
        """生成滲透測試報告"""
        print("\n" + "=" * 70)
        print("AIVA 實戰滲透測試結果報告")
        print("=" * 70)
        
        print(f"測試會話: {self.session_id}")
        print(f"完成時間: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"總發現數: {len(findings)}")
        
        if not findings:
            print("\n[INFO] 未發現明顯的安全漏洞")
            print("這表示測試目標具有良好的安全防護，或需要更深入的測試策略")
        else:
            print(f"\n[ALERT] 發現 {len(findings)} 個潛在安全問題:")
            
            for i, finding in enumerate(findings, 1):
                print(f"\n漏洞 #{i}:")
                if 'finding' in finding:
                    # XSS 漏洞
                    f = finding['finding']
                    print(f"  類型: {f.vulnerability.name}")
                    print(f"  嚴重性: {f.vulnerability.severity}")
                    print(f"  目標: {f.target.url}")
                    print(f"  參數: {f.target.parameter}")
                    print(f"  Payload: {finding['payload']}")
                else:
                    # 其他類型漏洞
                    print(f"  類型: {finding['type']}")
                    print(f"  目標: {finding['url']}")
                    if 'params' in finding:
                        print(f"  參數: {finding['params']}")
        
        # 保存詳細報告到檔案
        report_data = {
            'session_id': self.session_id,
            'timestamp': datetime.now().isoformat(),
            'findings_count': len(findings),
            'findings': []
        }
        
        for finding in findings:
            if 'finding' in finding:
                # 序列化 FindingPayload
                report_data['findings'].append({
                    'type': 'xss_vulnerability',
                    'finding_data': finding['finding'].model_dump(),
                    'payload': finding['payload'],
                    'response_length': finding['response_length']
                })
            else:
                report_data['findings'].append(finding)
        
        # 儲存報告
        report_filename = f"reports/pentest_report_{self.session_id}.json"
        try:
            import os
            os.makedirs('reports', exist_ok=True)
            with open(report_filename, 'w', encoding='utf-8') as f:
                json.dump(report_data, f, indent=2, ensure_ascii=False)
            print(f"\n[SAVED] 詳細報告已儲存至: {report_filename}")
        except Exception as e:
            print(f"\n[ERROR] 報告儲存失敗: {e}")
        
        print("\n" + "=" * 70)
        print("實戰滲透測試完成")
        print("=" * 70)

async def main():
    """主程序入口"""
    runner = LivePentestRunner()
    await runner.run_comprehensive_test()

if __name__ == "__main__":
    asyncio.run(main())