#!/usr/bin/env python3
"""
çµ±ä¸€ Schema ç”Ÿæˆå·¥å…·

æ­¤å·¥å…·ç”¨æ–¼å¾ Python Pydantic æ¨¡å‹ç”Ÿæˆå…¶ä»–èªè¨€çš„å‹åˆ¥å®šç¾©ï¼Œ
ç¢ºä¿è·¨èªè¨€å‹åˆ¥ä¸€è‡´æ€§å’ŒåŒæ­¥æ›´æ–°ã€‚

ä½¿ç”¨æ–¹æ³•:
    python schema_generator.py --source schemas/ --output-dir generated/
"""

import json
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List

import typer
from pydantic import BaseModel
from pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue


class AIVAJsonSchemaGenerator(GenerateJsonSchema):
    """
    è‡ªå®šç¾© JSON Schema ç”Ÿæˆå™¨
    é‡å° AIVA å°ˆæ¡ˆçš„ç‰¹æ®Šéœ€æ±‚é€²è¡Œå„ªåŒ–
    """

    def generate_schema(self, schema: JsonSchemaValue) -> Dict[str, Any]:
        """ç”Ÿæˆå„ªåŒ–çš„ JSON Schema"""
        json_schema = super().generate_schema(schema)
        
        # æ·»åŠ  AIVA ç‰¹å®šçš„å…ƒæ•¸æ“š
        json_schema["$schema"] = "https://json-schema.org/draft/2020-12/schema"
        json_schema["$id"] = "https://aiva.security/schemas/main"
        json_schema["title"] = "AIVA Security Platform Schemas"
        json_schema["description"] = "Unified data schemas for AIVA security platform"
        json_schema["version"] = "1.0.0"
        json_schema["generated_at"] = datetime.utcnow().isoformat()
        json_schema["generator"] = "AIVA Official Schema Generator v1.0"
        
        return json_schema


class SchemaGenerator:
    """Schema ç”Ÿæˆå™¨ä¸»é¡"""
    
    def __init__(self, source_dir: Path, output_dir: Path):
        self.source_dir = source_dir
        self.output_dir = output_dir
        self.output_dir.mkdir(exist_ok=True, parents=True)
    
    def generate_typescript(self, json_schema: Dict[str, Any]) -> str:
        """ç”Ÿæˆ TypeScript å‹åˆ¥å®šç¾©"""
        header = f"""// AUTO-GENERATED by AIVA Official Schema Generator v1.0
// Generated at: {datetime.utcnow().isoformat()}
// Do not edit manually - changes will be overwritten

"""
        
        # é€™è£¡å¯¦ä½œ JSON Schema åˆ° TypeScript çš„è½‰æ›é‚è¼¯
        # å¯ä»¥ä½¿ç”¨ json-schema-to-typescript æˆ–è‡ªå®šç¾©å¯¦ä½œ
        
        return header + self._json_schema_to_typescript(json_schema)
    
    def generate_go(self, json_schema: Dict[str, Any]) -> str:
        """ç”Ÿæˆ Go çµæ§‹é«”å®šç¾©"""
        header = f"""// Code generated by AIVA Official Schema Generator v1.0. DO NOT EDIT.
// Generated at: {datetime.utcnow().isoformat()}
//
// To parse this JSON data, add this code to your project:
//    aivaSchemas, err := UnmarshalAIVASchemas(bytes)
//    bytes, err = aivaSchemas.Marshal()

package schemas

import (
	"encoding/json"
	"time"
)

"""
        
        return header + self._json_schema_to_go(json_schema)
    
    def generate_rust(self, json_schema: Dict[str, Any]) -> str:
        """ç”Ÿæˆ Rust çµæ§‹é«”å®šç¾©"""
        header = f"""// Code generated by AIVA Official Schema Generator v1.0. DO NOT EDIT.
// Generated at: {datetime.utcnow().isoformat()}

use serde::{{Deserialize, Serialize}};
use chrono::{{DateTime, Utc}};
use std::collections::HashMap;

"""
        
        return header + self._json_schema_to_rust(json_schema)
    
    def _json_schema_to_typescript(self, schema: Dict[str, Any]) -> str:
        """å°‡ JSON Schema è½‰æ›ç‚º TypeScript"""
        # TODO: å¯¦ä½œè½‰æ›é‚è¼¯
        return "// TypeScript definitions will be generated here\n"
    
    def _json_schema_to_go(self, schema: Dict[str, Any]) -> str:
        """å°‡ JSON Schema è½‰æ›ç‚º Go"""
        # TODO: å¯¦ä½œè½‰æ›é‚è¼¯  
        return "// Go structs will be generated here\n"
    
    def _json_schema_to_rust(self, schema: Dict[str, Any]) -> str:
        """å°‡ JSON Schema è½‰æ›ç‚º Rust"""
        # TODO: å¯¦ä½œè½‰æ›é‚è¼¯
        return "// Rust structs will be generated here\n"
    
    def generate_all(self) -> None:
        """ç”Ÿæˆæ‰€æœ‰èªè¨€çš„å‹åˆ¥å®šç¾©"""
        # 1. å¾ Python æ¨¡å‹ç”Ÿæˆ JSON Schema
        json_schema = self._extract_json_schema()
        
        # 2. ä¿å­˜ JSON Schema
        json_file = self.output_dir / "aiva_schemas.json"
        with open(json_file, 'w', encoding='utf-8') as f:
            json.dump(json_schema, f, indent=2, ensure_ascii=False)
        
        # 3. ç”Ÿæˆå„èªè¨€å®šç¾©
        languages = {
            "aiva_schemas.d.ts": self.generate_typescript,
            "aiva_schemas.go": self.generate_go, 
            "aiva_schemas.rs": self.generate_rust,
        }
        
        for filename, generator in languages.items():
            content = generator(json_schema)
            output_file = self.output_dir / filename
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(content)
            
            print(f"âœ… Generated {filename}")
    
    def _extract_json_schema(self) -> Dict[str, Any]:
        """å¾ Python Pydantic æ¨¡å‹æå– JSON Schema"""
        # TODO: å‹•æ…‹å°å…¥æ‰€æœ‰ Pydantic æ¨¡å‹ä¸¦ç”Ÿæˆçµ±ä¸€ JSON Schema
        # é€™éœ€è¦éæ­· services/aiva_common/schemas/ ä¸‹çš„æ‰€æœ‰ Python æª”æ¡ˆ
        return {
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "$defs": {},
            "title": "AIVA Schemas"
        }


def main(
    source_dir: Path = typer.Option(
        Path("services/aiva_common/schemas"),
        "--source",
        "-s", 
        help="Source directory containing Python schemas"
    ),
    output_dir: Path = typer.Option(
        Path("schemas/generated"),
        "--output-dir",
        "-o",
        help="Output directory for generated files"
    ),
    validate: bool = typer.Option(
        True,
        "--validate",
        help="Validate generated schemas"
    )
):
    """
    AIVA Schema Generator - çµ±ä¸€è·¨èªè¨€å‹åˆ¥å®šç¾©ç”Ÿæˆå·¥å…·
    """
    print("ğŸš€ AIVA Schema Generator v1.0")
    print(f"ğŸ“‚ Source: {source_dir}")
    print(f"ğŸ“‚ Output: {output_dir}")
    
    generator = SchemaGenerator(source_dir, output_dir)
    generator.generate_all()
    
    if validate:
        print("ğŸ” Validating generated schemas...")
        # TODO: å¯¦ä½œé©—è­‰é‚è¼¯
    
    print("âœ… Schema generation completed successfully!")


if __name__ == "__main__":
    typer.run(main)