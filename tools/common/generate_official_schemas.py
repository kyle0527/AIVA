#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Official Schema Generator Tool
Using Pydantic Official API and Standard Tools for Multi-language Schema Generation

Replacing custom aiva-contracts-tooling with official solutions:
- Pydantic Official JSON Schema Generation
- datamodel-code-generator Multi-language Generation  
- Standardized Output Format
"""

import json
import sys
import subprocess
from pathlib import Path
from typing import Dict, Any, List, Type, get_type_hints
import importlib
import inspect
from datetime import datetime
from pydantic import BaseModel


class OfficialSchemaGenerator:
    """å®˜æ–¹ Schema ç”Ÿæˆå™¨"""
    
    def __init__(self, output_dir: Path = None):
        self.output_dir = output_dir or Path("schemas")
        self.output_dir.mkdir(exist_ok=True)
        
    def discover_pydantic_models(self) -> Dict[str, Type[BaseModel]]:
        """ç™¼ç¾æ‰€æœ‰ Pydantic æ¨¡å‹"""
        print("Finding Pydantic models...")
        
        try:
            # Add current directory to Python path
            import sys
            from pathlib import Path
            project_root = Path(__file__).parent.parent
            if str(project_root) not in sys.path:
                sys.path.insert(0, str(project_root))
            
            # Import aiva_common.schemas
            schemas_module = importlib.import_module("services.aiva_common.schemas")
            
            models = {}
            # Get all exported classes from __all__
            all_exports = getattr(schemas_module, "__all__", [])
            
            for name in all_exports:
                if hasattr(schemas_module, name):
                    obj = getattr(schemas_module, name)
                    if inspect.isclass(obj) and issubclass(obj, BaseModel):
                        models[name] = obj
                        
            print(f"Found {len(models)} Pydantic models")
            return models
            
        except Exception as e:
            print(f"âŒ æ¨¡å‹ç™¼ç¾å¤±æ•—: {e}")
            return {}
    
    def generate_official_json_schema(self, models: Dict[str, Type[BaseModel]]) -> Path:
        """ä½¿ç”¨ Pydantic å®˜æ–¹ API ç”Ÿæˆ JSON Schema"""
        print("Generating official JSON Schema...")
        
        # ä½¿ç”¨ Pydantic å®˜æ–¹ API
        schema_bundle = {
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "$id": "aiva-schemas",
            "title": "AIVA Schema Bundle",
            "description": "AIVA å¹³å°çµ±ä¸€è³‡æ–™çµæ§‹å®šç¾©",
            "version": "1.0.0",
            "generated_at": datetime.now().isoformat(),
            "generator": "Pydantic Official API",
            "$defs": {}
        }
        
        # ç‚ºæ¯å€‹æ¨¡å‹ç”Ÿæˆ Schema
        for name, model_class in models.items():
            try:
                # ä½¿ç”¨ Pydantic å®˜æ–¹ model_json_schema() æ–¹æ³•
                model_schema = model_class.model_json_schema()
                
                # ç§»é™¤é ‚å±¤çš„ $defsï¼Œåˆä½µåˆ°å…¨å±€ $defs
                if "$defs" in model_schema:
                    schema_bundle["$defs"].update(model_schema["$defs"])
                    del model_schema["$defs"]
                
                schema_bundle["$defs"][name] = model_schema
                
            except Exception as e:
                print(f"âš ï¸ æ¨¡å‹ {name} Schema ç”Ÿæˆå¤±æ•—: {e}")
        
        # Output JSON Schema
        output_path = self.output_dir / "aiva_schemas.json"
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(schema_bundle, f, indent=2, ensure_ascii=False)
        
        file_size = output_path.stat().st_size
        print(f"JSON Schema generated: {output_path}")
        print(f"File size: {file_size // 1024:.1f} KB")
        print(f"Schema count: {len(schema_bundle['$defs'])}")
        
        return output_path
    
    def generate_typescript_definitions(self, json_schema_path: Path) -> Path:
        """ç”Ÿæˆ TypeScript å®šç¾©æª”"""
        print("ğŸ”§ ç”Ÿæˆ TypeScript å®šç¾©...")
        
        output_path = self.output_dir / "aiva_schemas.d.ts"
        
        try:
            # Use datamodel-code-generator official tool
            cmd = [
                "datamodel-codegen",
                "--input", str(json_schema_path),
                "--input-file-type", "jsonschema", 
                "--output", str(output_path),
                "--output-model-type", "pydantic.BaseModel",  # TypeScript not directly supported
                "--target-python-version", "3.13"
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                # æ·»åŠ è‡ªå‹•ç”Ÿæˆæ¨™è¨˜
                content = output_path.read_text(encoding='utf-8')
                header = f"""// AUTO-GENERATED by Pydantic Official Tools
// Generated at: {datetime.now().isoformat()}
// Do not edit manually - changes will be overwritten

"""
                output_path.write_text(header + content, encoding='utf-8')
                
                file_size = output_path.stat().st_size
                print(f"âœ… TypeScript å®šç¾©å·²ç”Ÿæˆ: {output_path}")
                print(f"ğŸ“Š æª”æ¡ˆå¤§å°: {file_size // 1024:.1f} KB")
                
                return output_path
            else:
                print(f"âŒ TypeScript ç”Ÿæˆå¤±æ•—: {result.stderr}")
                return None
                
        except Exception as e:
            print(f"âŒ TypeScript ç”Ÿæˆéç¨‹å‡ºéŒ¯: {e}")
            return None
    
    def generate_go_structs(self, json_schema_path: Path) -> Path:
        """ç”Ÿæˆ Go çµæ§‹é«”"""
        print("ğŸ¹ ç”Ÿæˆ Go çµæ§‹é«”...")
        
        output_path = self.output_dir / "aiva_schemas.go"
        
        try:
            cmd = [
                sys.executable, "-m", "datamodel_codegen",
                "--input", str(json_schema_path),
                "--input-file-type", "jsonschema",
                "--output", str(output_path), 
                "--output-model-type", "dataclasses.dataclass",  # æœ€æ¥è¿‘çš„æ ¼å¼
                "--target-python-version", "3.13"
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                print(f"âœ… Go çµæ§‹é«”å·²ç”Ÿæˆ: {output_path}")
                return output_path
            else:
                print(f"âš ï¸ Go ç”Ÿæˆè·³é (å·¥å…·é™åˆ¶): {result.stderr}")
                return None
                
        except Exception as e:
            print(f"âš ï¸ Go ç”Ÿæˆè·³é: {e}")
            return None
    
    def generate_enums_typescript(self) -> Path:
        """ç”Ÿæˆ TypeScript æšèˆ‰"""
        print("ğŸ”¢ ç”Ÿæˆ TypeScript æšèˆ‰...")
        
        try:
            # å°å…¥æšèˆ‰æ¨¡çµ„
            enums_module = importlib.import_module("services.aiva_common.enums")
            
            enum_lines = [
                "// AUTO-GENERATED from aiva_common.enums; do not edit.\n",
                f"// Generated at: {datetime.now().isoformat()}\n\n"
            ]
            
            # ç²å–æ‰€æœ‰æšèˆ‰
            all_enums = getattr(enums_module, "__all__", [])
            
            for enum_name in all_enums:
                if hasattr(enums_module, enum_name):
                    enum_class = getattr(enums_module, enum_name)
                    if hasattr(enum_class, '__members__'):
                        # ç”Ÿæˆ TypeScript æšèˆ‰
                        enum_lines.append(f"export enum {enum_name} {{")
                        members = []
                        for member_name, member in enum_class.__members__.items():
                            members.append(f"  {member_name} = '{member.value}'")
                        enum_lines.append(",\n".join(members) + "\n")
                        enum_lines.append("}\n")
            
            # è¼¸å‡ºæª”æ¡ˆ
            output_path = self.output_dir / "enums.ts"
            output_path.write_text("".join(enum_lines), encoding='utf-8')
            
            print(f"âœ… TypeScript æšèˆ‰å·²ç”Ÿæˆ: {output_path}")
            print(f"ğŸ“Š æšèˆ‰æ•¸é‡: {len(all_enums)}")
            
            return output_path
            
        except Exception as e:
            print(f"âŒ æšèˆ‰ç”Ÿæˆå¤±æ•—: {e}")
            return None
    
    def run_full_generation(self):
        """Execute full generation process"""
        print("Starting official Schema generation process")
        print("=" * 60)
        
        # 1. ç™¼ç¾æ¨¡å‹
        models = self.discover_pydantic_models()
        if not models:
            print("âŒ æ²’æœ‰ç™¼ç¾ä»»ä½•æ¨¡å‹ï¼Œçµ‚æ­¢ç”Ÿæˆ")
            return
        
        # 2. ç”Ÿæˆ JSON Schema
        json_path = self.generate_official_json_schema(models)
        if not json_path:
            print("âŒ JSON Schema ç”Ÿæˆå¤±æ•—ï¼Œçµ‚æ­¢æµç¨‹")
            return
        
        # 3. ç”Ÿæˆ TypeScript å®šç¾©
        ts_path = self.generate_typescript_definitions(json_path)
        
        # 4. ç”Ÿæˆ Go çµæ§‹é«”ï¼ˆå¯é¸ï¼‰
        go_path = self.generate_go_structs(json_path)
        
        # 5. ç”Ÿæˆ TypeScript æšèˆ‰
        enum_path = self.generate_enums_typescript()
        
        print("\n" + "=" * 60)
        print("ğŸ‰ å®˜æ–¹ Schema ç”Ÿæˆå®Œæˆ!")
        print("=" * 60)
        
        # ç¸½çµ
        generated_files = [json_path]
        if ts_path: generated_files.append(ts_path)
        if go_path: generated_files.append(go_path)
        if enum_path: generated_files.append(enum_path)
        
        print(f"ğŸ“¦ å·²ç”Ÿæˆ {len(generated_files)} å€‹æª”æ¡ˆ:")
        for file_path in generated_files:
            size = file_path.stat().st_size if file_path.exists() else 0
            print(f"   ğŸ“„ {file_path.name}: {size // 1024:.1f} KB")


def main():
    """Main function"""
    print("AIVA Official Schema Generator Tool")
    print("Using Pydantic Official API + datamodel-code-generator")
    print()
    
    # Ensure in correct directory
    project_root = Path.cwd()
    
    # Initialize generator
    generator = OfficialSchemaGenerator(
        output_dir=project_root / "schemas"
    )
    
    # Execute generation
    generator.run_full_generation()


if __name__ == "__main__":
    main()