#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Official Schema Generator Tool
Using Pydantic Official API and Standard Tools for Multi-language Schema Generation

Replacing custom aiva-contracts-tooling with official solutions:
- Pydantic Official JSON Schema Generation
- datamodel-code-generator Multi-language Generation  
- Standardized Output Format
"""

import json
import sys
import subprocess
from pathlib import Path
from typing import Dict, Any, List, Type, get_type_hints
import importlib
import inspect
from datetime import datetime
from pydantic import BaseModel


class OfficialSchemaGenerator:
    """官方 Schema 生成器"""
    
    def __init__(self, output_dir: Path = None):
        self.output_dir = output_dir or Path("schemas")
        self.output_dir.mkdir(exist_ok=True)
        
    def discover_pydantic_models(self) -> Dict[str, Type[BaseModel]]:
        """發現所有 Pydantic 模型"""
        print("Finding Pydantic models...")
        
        try:
            # Add current directory to Python path
            import sys
            from pathlib import Path
            project_root = Path(__file__).parent.parent
            if str(project_root) not in sys.path:
                sys.path.insert(0, str(project_root))
            
            # Import aiva_common.schemas
            schemas_module = importlib.import_module("services.aiva_common.schemas")
            
            models = {}
            # Get all exported classes from __all__
            all_exports = getattr(schemas_module, "__all__", [])
            
            for name in all_exports:
                if hasattr(schemas_module, name):
                    obj = getattr(schemas_module, name)
                    if inspect.isclass(obj) and issubclass(obj, BaseModel):
                        models[name] = obj
                        
            print(f"Found {len(models)} Pydantic models")
            return models
            
        except Exception as e:
            print(f"❌ 模型發現失敗: {e}")
            return {}
    
    def generate_official_json_schema(self, models: Dict[str, Type[BaseModel]]) -> Path:
        """使用 Pydantic 官方 API 生成 JSON Schema"""
        print("Generating official JSON Schema...")
        
        # 使用 Pydantic 官方 API
        schema_bundle = {
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "$id": "aiva-schemas",
            "title": "AIVA Schema Bundle",
            "description": "AIVA 平台統一資料結構定義",
            "version": "1.0.0",
            "generated_at": datetime.now().isoformat(),
            "generator": "Pydantic Official API",
            "$defs": {}
        }
        
        # 為每個模型生成 Schema
        for name, model_class in models.items():
            try:
                # 使用 Pydantic 官方 model_json_schema() 方法
                model_schema = model_class.model_json_schema()
                
                # 移除頂層的 $defs，合併到全局 $defs
                if "$defs" in model_schema:
                    schema_bundle["$defs"].update(model_schema["$defs"])
                    del model_schema["$defs"]
                
                schema_bundle["$defs"][name] = model_schema
                
            except Exception as e:
                print(f"⚠️ 模型 {name} Schema 生成失敗: {e}")
        
        # Output JSON Schema
        output_path = self.output_dir / "aiva_schemas.json"
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(schema_bundle, f, indent=2, ensure_ascii=False)
        
        file_size = output_path.stat().st_size
        print(f"JSON Schema generated: {output_path}")
        print(f"File size: {file_size // 1024:.1f} KB")
        print(f"Schema count: {len(schema_bundle['$defs'])}")
        
        return output_path
    
    def generate_typescript_definitions(self, json_schema_path: Path) -> Path:
        """生成 TypeScript 定義檔"""
        print("🔧 生成 TypeScript 定義...")
        
        output_path = self.output_dir / "aiva_schemas.d.ts"
        
        try:
            # Use datamodel-code-generator official tool
            cmd = [
                "datamodel-codegen",
                "--input", str(json_schema_path),
                "--input-file-type", "jsonschema", 
                "--output", str(output_path),
                "--output-model-type", "pydantic.BaseModel",  # TypeScript not directly supported
                "--target-python-version", "3.13"
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                # 添加自動生成標記
                content = output_path.read_text(encoding='utf-8')
                header = f"""// AUTO-GENERATED by Pydantic Official Tools
// Generated at: {datetime.now().isoformat()}
// Do not edit manually - changes will be overwritten

"""
                output_path.write_text(header + content, encoding='utf-8')
                
                file_size = output_path.stat().st_size
                print(f"✅ TypeScript 定義已生成: {output_path}")
                print(f"📊 檔案大小: {file_size // 1024:.1f} KB")
                
                return output_path
            else:
                print(f"❌ TypeScript 生成失敗: {result.stderr}")
                return None
                
        except Exception as e:
            print(f"❌ TypeScript 生成過程出錯: {e}")
            return None
    
    def generate_go_structs(self, json_schema_path: Path) -> Path:
        """生成 Go 結構體"""
        print("🐹 生成 Go 結構體...")
        
        output_path = self.output_dir / "aiva_schemas.go"
        
        try:
            cmd = [
                sys.executable, "-m", "datamodel_codegen",
                "--input", str(json_schema_path),
                "--input-file-type", "jsonschema",
                "--output", str(output_path), 
                "--output-model-type", "dataclasses.dataclass",  # 最接近的格式
                "--target-python-version", "3.13"
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                print(f"✅ Go 結構體已生成: {output_path}")
                return output_path
            else:
                print(f"⚠️ Go 生成跳過 (工具限制): {result.stderr}")
                return None
                
        except Exception as e:
            print(f"⚠️ Go 生成跳過: {e}")
            return None
    
    def generate_enums_typescript(self) -> Path:
        """生成 TypeScript 枚舉"""
        print("🔢 生成 TypeScript 枚舉...")
        
        try:
            # 導入枚舉模組
            enums_module = importlib.import_module("services.aiva_common.enums")
            
            enum_lines = [
                "// AUTO-GENERATED from aiva_common.enums; do not edit.\n",
                f"// Generated at: {datetime.now().isoformat()}\n\n"
            ]
            
            # 獲取所有枚舉
            all_enums = getattr(enums_module, "__all__", [])
            
            for enum_name in all_enums:
                if hasattr(enums_module, enum_name):
                    enum_class = getattr(enums_module, enum_name)
                    if hasattr(enum_class, '__members__'):
                        # 生成 TypeScript 枚舉
                        enum_lines.append(f"export enum {enum_name} {{")
                        members = []
                        for member_name, member in enum_class.__members__.items():
                            members.append(f"  {member_name} = '{member.value}'")
                        enum_lines.append(",\n".join(members) + "\n")
                        enum_lines.append("}\n")
            
            # 輸出檔案
            output_path = self.output_dir / "enums.ts"
            output_path.write_text("".join(enum_lines), encoding='utf-8')
            
            print(f"✅ TypeScript 枚舉已生成: {output_path}")
            print(f"📊 枚舉數量: {len(all_enums)}")
            
            return output_path
            
        except Exception as e:
            print(f"❌ 枚舉生成失敗: {e}")
            return None
    
    def run_full_generation(self):
        """Execute full generation process"""
        print("Starting official Schema generation process")
        print("=" * 60)
        
        # 1. 發現模型
        models = self.discover_pydantic_models()
        if not models:
            print("❌ 沒有發現任何模型，終止生成")
            return
        
        # 2. 生成 JSON Schema
        json_path = self.generate_official_json_schema(models)
        if not json_path:
            print("❌ JSON Schema 生成失敗，終止流程")
            return
        
        # 3. 生成 TypeScript 定義
        ts_path = self.generate_typescript_definitions(json_path)
        
        # 4. 生成 Go 結構體（可選）
        go_path = self.generate_go_structs(json_path)
        
        # 5. 生成 TypeScript 枚舉
        enum_path = self.generate_enums_typescript()
        
        print("\n" + "=" * 60)
        print("🎉 官方 Schema 生成完成!")
        print("=" * 60)
        
        # 總結
        generated_files = [json_path]
        if ts_path: generated_files.append(ts_path)
        if go_path: generated_files.append(go_path)
        if enum_path: generated_files.append(enum_path)
        
        print(f"📦 已生成 {len(generated_files)} 個檔案:")
        for file_path in generated_files:
            size = file_path.stat().st_size if file_path.exists() else 0
            print(f"   📄 {file_path.name}: {size // 1024:.1f} KB")


def main():
    """Main function"""
    print("AIVA Official Schema Generator Tool")
    print("Using Pydantic Official API + datamodel-code-generator")
    print()
    
    # Ensure in correct directory
    project_root = Path.cwd()
    
    # Initialize generator
    generator = OfficialSchemaGenerator(
        output_dir=project_root / "schemas"
    )
    
    # Execute generation
    generator.run_full_generation()


if __name__ == "__main__":
    main()