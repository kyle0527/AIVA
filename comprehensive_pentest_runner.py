#!/usr/bin/env python3
"""
AIVA 綜合實戰滲透測試執行器

修復所有依賴問題後的完整滲透測試工具
遵循 aiva_common 規範，使用標準化的編碼和導入
"""

import asyncio
import sys
import time
from pathlib import Path
from typing import List, Dict, Any

# 設置路徑
PROJECT_ROOT = Path(__file__).parent
sys.path.insert(0, str(PROJECT_ROOT))
sys.path.insert(0, str(PROJECT_ROOT / "services"))

print("[OK] AIVA 綜合實戰滲透測試執行器 v2.0")
print("=" * 50)

class ComprehensivePentestRunner:
    """
    綜合滲透測試執行器
    
    修復所有編碼和依賴問題後的完整版本
    """
    
    def __init__(self):
        self.test_targets = [
            "https://httpbin.org",
            "https://jsonplaceholder.typicode.com"
        ]
        self.results = {
            "connectivity": [],
            "sqli_test": [],
            "xss_test": [],
            "ai_dialogue": [],
            "system_validation": []
        }
    
    async def test_connectivity(self):
        """測試目標連通性"""
        print("\n[STEP 1] 測試目標連通性...")
        print("-" * 30)
        
        try:
            import aiohttp
            
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=10)) as session:
                for target in self.test_targets:
                    try:
                        async with session.get(target) as response:
                            status = response.status
                            self.results["connectivity"].append({
                                "target": target,
                                "status": status,
                                "success": status == 200
                            })
                            
                            if status == 200:
                                print(f"[OK] {target} - 連通性測試成功 (狀態碼: {status})")
                            else:
                                print(f"[WARN] {target} - 狀態碼: {status}")
                    
                    except Exception as e:
                        print(f"[FAIL] {target} - 連接失敗: {e}")
                        self.results["connectivity"].append({
                            "target": target,
                            "status": None,
                            "success": False,
                            "error": str(e)
                        })
        
        except ImportError:
            print("[WARN] aiohttp 未安裝，跳過連通性測試")
            return False
        
        return len([r for r in self.results["connectivity"] if r["success"]]) > 0
    
    def test_sqli_scanner(self):
        """測試 SQLi 掃描器"""
        print("\n[STEP 2] 測試 SQL 注入掃描器...")
        print("-" * 35)
        
        try:
            # 測試直接導入 SQLi scanner 組件
            from services.features.function_sqli.payload_generator import SqliPayloadGenerator
            from services.features.function_sqli.error_detector import ErrorBasedDetector
            
            print("[OK] SQLi 掃描器組件導入成功")
            
            # 創建組件實例
            payload_gen = SqliPayloadGenerator()
            error_detector = ErrorBasedDetector()
            
            print("[OK] SQLi 組件初始化成功")
            
            # 生成測試 payload
            test_payloads = payload_gen.generate_error_payloads()
            print(f"[OK] 生成了 {len(test_payloads)} 個 SQLi 錯誤檢測 payloads")
            
            # 顯示前幾個 payload
            print("前5個 SQLi payloads:")
            for i, payload in enumerate(test_payloads[:5]):
                print(f"  {i+1}. {payload}")
            
            # 測試錯誤檢測
            test_responses = [
                "You have an error in your SQL syntax",
                "ORA-00942: table or view does not exist",
                "Normal response without errors"
            ]
            
            detection_count = 0
            for response in test_responses:
                if error_detector.has_error_indicators(response):
                    detection_count += 1
                    print(f"[OK] 錯誤檢測成功: '{response[:50]}...'")
            
            print(f"[OK] SQLi 錯誤檢測器工作正常 ({detection_count}/3 個測試響應)")
            
            self.results["sqli_test"] = {
                "status": "success",
                "payloads_generated": len(test_payloads),
                "error_detection_rate": detection_count / len(test_responses)
            }
            
            return True
            
        except Exception as e:
            print(f"[FAIL] SQLi 掃描器測試失敗: {e}")
            self.results["sqli_test"] = {
                "status": "failed",
                "error": str(e)
            }
            return False
    
    def test_xss_scanner(self):
        """測試 XSS 掃描器"""
        print("\n[STEP 3] 測試 XSS 掃描器...")
        print("-" * 30)
        
        try:
            # 測試修復後的 XSS scanner 導入
            from services.features.function_xss.payload_generator import XssPayloadGenerator
            from services.features.function_xss.dom_xss_detector import DomXssDetector
            
            print("[OK] XSS 掃描器組件導入成功")
            
            # 創建組件實例
            payload_gen = XssPayloadGenerator()
            dom_detector = DomXssDetector()
            
            print("[OK] XSS 組件初始化成功")
            
            # 生成測試 payload
            basic_payloads = payload_gen.generate_basic_payloads()
            advanced_payloads = payload_gen.generate_advanced_payloads()
            
            total_payloads = len(basic_payloads) + len(advanced_payloads)
            print(f"[OK] 生成了 {total_payloads} 個 XSS payloads")
            print(f"   - 基礎 payloads: {len(basic_payloads)}")
            print(f"   - 高級 payloads: {len(advanced_payloads)}")
            
            # 顯示前幾個 payload
            print("前5個 XSS payloads:")
            for i, payload in enumerate(basic_payloads[:5]):
                print(f"  {i+1}. {payload}")
            
            # 測試 DOM XSS 檢測
            test_cases = [
                {
                    "payload": "alert(1)",
                    "html": '<script>alert(1)</script><p>test</p>',
                    "should_detect": True
                },
                {
                    "payload": "alert(2)",
                    "html": '<img src=x onerror="alert(2)"><p>test</p>',
                    "should_detect": True
                },
                {
                    "payload": "safe_text",
                    "html": '<p>safe_text in normal context</p>',
                    "should_detect": False
                }
            ]
            
            detection_success = 0
            for case in test_cases:
                result = dom_detector.analyze(
                    payload=case["payload"], 
                    document=case["html"]
                )
                
                detected = result is not None
                expected = case["should_detect"]
                
                if detected == expected:
                    detection_success += 1
                    status = "[OK]" if detected else "[OK]"
                    print(f"{status} DOM 檢測正確: payload='{case['payload']}', detected={detected}")
                else:
                    print(f"[WARN] DOM 檢測不準確: payload='{case['payload']}', expected={expected}, got={detected}")
            
            print(f"[OK] XSS 檢測準確率: {detection_success}/{len(test_cases)}")
            
            self.results["xss_test"] = {
                "status": "success",
                "basic_payloads": len(basic_payloads),
                "advanced_payloads": len(advanced_payloads),
                "detection_accuracy": detection_success / len(test_cases)
            }
            
            return True
            
        except Exception as e:
            print(f"[FAIL] XSS 掃描器測試失敗: {e}")
            import traceback
            traceback.print_exc()
            self.results["xss_test"] = {
                "status": "failed",
                "error": str(e)
            }
            return False
    
    def test_ai_dialogue_assistant(self):
        """測試 AI 對話助手"""
        print("\n[STEP 4] 測試 AI 對話助手...")
        print("-" * 35)
        
        try:
            from services.aiva_common.ai.dialog_assistant import AIVADialogAssistant
            
            assistant = AIVADialogAssistant()
            print("[OK] AI 對話助手初始化成功")
            
            # 測試滲透測試相關查詢
            test_queries = [
                "如何進行XSS測試？",
                "SQL注入的基本原理是什麼？",
                "我要測試一個登錄頁面的安全性",
                "分析這個HTTP響應是否有漏洞"
            ]
            
            successful_responses = 0
            for query in test_queries:
                try:
                    response = assistant.process_query(query)
                    if response and len(response.strip()) > 10:
                        successful_responses += 1
                        print(f"[OK] 查詢成功: '{query[:30]}...' -> {len(response)} 字符回應")
                    else:
                        print(f"[WARN] 查詢回應不佳: '{query[:30]}...'")
                except Exception as e:
                    print(f"[FAIL] 查詢失敗: '{query[:30]}...' - {e}")
            
            print(f"[OK] AI 助手回應成功率: {successful_responses}/{len(test_queries)}")
            
            self.results["ai_dialogue"] = {
                "status": "success",
                "queries_processed": successful_responses,
                "total_queries": len(test_queries),
                "success_rate": successful_responses / len(test_queries)
            }
            
            return successful_responses > 0
            
        except Exception as e:
            print(f"[FAIL] AI 對話助手測試失敗: {e}")
            self.results["ai_dialogue"] = {
                "status": "failed",
                "error": str(e)
            }
            return False
    
    def validate_system_health(self):
        """驗證系統整體健康狀態"""
        print("\n[STEP 5] 系統整體健康狀態驗證...")
        print("-" * 40)
        
        try:
            # 測試核心模組導入
            from services.aiva_common.enums import Severity, Confidence, VulnerabilityType
            from services.aiva_common.schemas import FindingPayload, ScanStartPayload
            
            print("[OK] aiva_common 核心模組導入成功")
            
            # 測試枚舉值
            severity_values = [s.value for s in Severity]
            confidence_values = [c.value for c in Confidence]
            vuln_types = [v.value for v in VulnerabilityType]
            
            print(f"[OK] 嚴重程度枚舉: {len(severity_values)} 個值")
            print(f"[OK] 可信度枚舉: {len(confidence_values)} 個值")
            print(f"[OK] 漏洞類型枚舉: {len(vuln_types)} 個值")
            
            # 測試數據結構創建
            test_finding = FindingPayload(
                finding_id="TEST-001",
                title="測試漏洞",
                severity=Severity.HIGH,
                confidence=Confidence.FIRM,
                description="這是一個測試漏洞"
            )
            
            print("[OK] FindingPayload 數據結構創建成功")
            
            test_scan = ScanStartPayload(
                scan_id="SCAN-001",
                target="https://example.com"
            )
            
            print("[OK] ScanStartPayload 數據結構創建成功")
            
            # 測試序列化
            finding_json = test_finding.model_dump_json()
            scan_json = test_scan.model_dump_json()
            
            print(f"[OK] 數據結構序列化成功: {len(finding_json)} + {len(scan_json)} 字符")
            
            self.results["system_validation"] = {
                "status": "success",
                "enums_loaded": len(severity_values) + len(confidence_values) + len(vuln_types),
                "schemas_working": True,
                "serialization_working": True
            }
            
            return True
            
        except Exception as e:
            print(f"[FAIL] 系統健康狀態驗證失敗: {e}")
            self.results["system_validation"] = {
                "status": "failed",
                "error": str(e)
            }
            return False
    
    async def run_comprehensive_test(self):
        """執行完整的滲透測試"""
        print(f"開始時間: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        
        # 執行所有測試步驟
        test_results = {
            "connectivity": await self.test_connectivity(),
            "sqli_scanner": self.test_sqli_scanner(),
            "xss_scanner": self.test_xss_scanner(),
            "ai_dialogue": self.test_ai_dialogue_assistant(),
            "system_health": self.validate_system_health()
        }
        
        # 生成測試報告
        print("\n" + "=" * 50)
        print("綜合滲透測試報告")
        print("=" * 50)
        
        total_tests = len(test_results)
        passed_tests = sum(1 for result in test_results.values() if result)
        
        print(f"總測試項目: {total_tests}")
        print(f"通過測試: {passed_tests}")
        print(f"整體成功率: {passed_tests/total_tests:.1%}")
        
        print("\n詳細結果:")
        for test_name, result in test_results.items():
            status = "[OK]" if result else "[FAIL]"
            print(f"  {status} {test_name.replace('_', ' ').title()}")
        
        # 顯示具體統計
        if self.results["sqli_test"].get("status") == "success":
            sqli = self.results["sqli_test"]
            print(f"\nSQLi 掃描器統計:")
            print(f"  - Payloads 生成: {sqli.get('payloads_generated', 0)}")
            print(f"  - 錯誤檢測率: {sqli.get('error_detection_rate', 0):.1%}")
        
        if self.results["xss_test"].get("status") == "success":
            xss = self.results["xss_test"]
            print(f"\nXSS 掃描器統計:")
            print(f"  - 基礎 payloads: {xss.get('basic_payloads', 0)}")
            print(f"  - 高級 payloads: {xss.get('advanced_payloads', 0)}")
            print(f"  - 檢測準確率: {xss.get('detection_accuracy', 0):.1%}")
        
        if self.results["ai_dialogue"].get("status") == "success":
            ai = self.results["ai_dialogue"]
            print(f"\nAI 對話助手統計:")
            print(f"  - 查詢處理: {ai.get('queries_processed', 0)}/{ai.get('total_queries', 0)}")
            print(f"  - 成功率: {ai.get('success_rate', 0):.1%}")
        
        print(f"\n結束時間: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        
        if passed_tests == total_tests:
            print("\n[SUCCESS] 所有測試通過！AIVA 系統準備就緒，可以進行實戰滲透測試！")
            return True
        else:
            print(f"\n[WARNING] {total_tests - passed_tests} 個測試失敗，請檢查相關組件")
            return False

async def main():
    """主執行函數"""
    runner = ComprehensivePentestRunner()
    success = await runner.run_comprehensive_test()
    
    if success:
        print("\n" + "="*50)
        print("🎯 實戰模式準備就緒")
        print("="*50)
        print("系統已通過所有驗證，可以開始實際的滲透測試任務：")
        print("1. SQLi 掃描器已就緒，可對實際目標進行SQL注入檢測")
        print("2. XSS 掃描器已就緒，可對實際目標進行跨站腳本檢測")
        print("3. AI 對話助手可協助分析滲透測試結果")
        print("4. 所有數據結構和枚舉正常工作")
        print("\n準備對以下目標進行實戰測試:")
        for target in runner.test_targets:
            print(f"  - {target}")
    
    return success

if __name__ == "__main__":
    # 執行綜合測試
    asyncio.run(main())